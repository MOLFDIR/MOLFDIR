C
      SUBROUTINE EXTRAP(DC,DO,DOC,FC,FO,FOC,SC1,SC2,SC3)
      IMPLICIT REAL*8 (A-H,O-Z)
C
      INCLUDE 'paracom.inc'
      INCLUDE 'general.inc'
      INCLUDE 'diis.inc'
C
      COMPLEX*16 DC(*),DO(*),FC(*),FO(*),SC1(*),SC2(*)
      COMPLEX*16 DOC(*),FOC(*),SC3(*)
C
      REAL*8 TRC, SPC
      LOGICAL POPLEF,DAMPF
C
C === WE START WITH CHECKING THE CONVERGENCE
C
      SPC = 0.0D0
C
      OPEN (MFDENSM, FILE='MFDENSM', FORM='UNFORMATTED',
     +      ACCESS='DIRECT',RECL=16 * LREC)
C
C === WE NEED THE DENSITY OF THE LAST ITERATION
C === AND THE DENSITY OF THE SECOND LAST ITERATION
C
      ICTC = 1
      ICTO = 1
      ICTO2 = 1
      DO 10 IRP = 1, NSYMRP
      NBS = NBSIM (IRP) * (NBSIM (IRP) + 1) / 2
      IF (NCL(IRP) .NE. 0) THEN
      CALL RDENS(IRECDC,DC(ICTC),NBS,IRP,1)
      CALL RDENS(IRECDP,FC(ICTC),NBS,IRP,1)
      ICTC = ICTC + NBS
      ENDIF
      IF (NOP(IRP,1) .NE. 0) THEN
      CALL RDENS(IRECDC,DO(ICTO),NBS,IRP,2)
      CALL RDENS(IRECDP,FO(ICTO),NBS,IRP,2)
      ICTO = ICTO + NBS
      ENDIF
      IF (NOP(IRP,2) .NE. 0) THEN
      CALL RDENS(IRECDC,DOC(ICTO2),NBS,IRP,3)
      CALL RDENS(IRECDP,FOC(ICTO2),NBS,IRP,3)
      ICTO2 = ICTO2 + NBS
      ENDIF
   10 CONTINUE
C === WE COMPUTE THE DIFFERENCE DP = D(LAST) - D(PREVIOUS)
#if defined (BIT64)
      CALL CAXPY(NBHTC,(-1.0E0,0.0E0),FC,1,DC,1)
#else
      CALL ZAXPY(NBHTC,(-1.0D0,0.0D0),FC,1,DC,1)
#endif
C     DO 100 I = 1, NBHTC
C     DC(I) = DC(I) - FC(I)
C 100 CONTINUE
      IF (OPENSH) THEN 
#if defined (BIT64)
        CALL CAXPY(NBHTO,(-1.0E0,0.0E0),FO,1,DO,1)
#else
        CALL ZAXPY(NBHTO,(-1.0D0,0.0D0),FO,1,DO,1)
#endif
C     DO 110 I = 1, NBHTC
C     DO(I) = DO(I) - FO(I)
C 110 CONTINUE
      ENDIF
      IF (OPENSH.AND.NOPEN.GT.1) THEN 
#if defined (BIT64)
        CALL CAXPY(NBHTO2,(-1.0E0,0.0E0),FOC,1,DOC,1)
#else
        CALL ZAXPY(NBHTO2,(-1.0D0,0.0D0),FOC,1,DOC,1)
#endif
C     DO 120 I = 1, NBHTC
C     DOC(I) = DOC(I) - FOC(I)
C 120 CONTINUE
      ENDIF
C === AND COMPUTE THE TRACE OF DP+ * DP
      IOFSC = 0
      IOFSO = 0
      IOFSO2 = 0 
      DO 200 IRP = 1, NSYMRP
      NB = NBSIM(IRP)
      NBH = NB * (NB + 1) / 2
      IF (NCL(IRP) .NE. 0) THEN
         SPC = SPC + TRC(DC(IOFSC+1),DC(IOFSC+1),NBH,NB)
         IOFSC = IOFSC + NBH
      ENDIF
      IF (NOP(IRP,1) .NE. 0) THEN
         SPC = SPC + TRC(DO(IOFSO+1),DO(IOFSO+1),NBH,NB)
         IOFSO = IOFSO + NBH
      ENDIF
      IF (NOP(IRP,2) .NE. 0) THEN
         SPC = SPC + TRC(DOC(IOFSO2+1),DOC(IOFSO2+1),NBH,NB)
         IOFSO2 = IOFSO2 + NBH
      ENDIF
  200 CONTINUE
C === CHECK IF WE'RE FINISHED
#if defined (BIT64)
      ACONV = SQRT(SPC) / NBTOT
#else
      ACONV = DSQRT(SPC) / NBTOT
#endif
      WRITE(6,1000) ICYCLS, ACONV
      IF (((NDIIS .LE. KCYCLS) .OR. (CODIIS .GE. ACONV)) .AND.
     +     (DFIRST) .AND. (NSLOTI .LT. ICYCLS)) THEN
         UDIIS = .TRUE.
         NPOPLE = 2 ** 30
         NDAMP = 2 ** 30
      ENDIF
      IF (LASTRUN) THEN
         IF ((PDIIS .GE. 2) .OR. (ACONV .LE. PRCONV)) THEN
            ENDRUN = .TRUE.
            RETURN
         ELSE
            PDIIS = PDIIS + 1
            PRCONV = ACONV
            RETURN
         ENDIF
      ENDIF
      IF (ACONV .LE. CONVTH) THEN
         IF (UDIIS) THEN
            LASTRUN = .TRUE.
            PDIIS = 1
         ELSE
            ENDRUN=.TRUE.
            RETURN
         ENDIF
      ENDIF
      IF (KCYCLS .GE. CCYCLS) THEN
         ENDRUN = .TRUE.
         RETURN
      ENDIF
C
C === WE HAVEN'T CONVERGED YET, MAYBE WE SHOULD EXTRAPOLATE
C === FIND OUT WHICH EXTRAPOLATION METHOD WE SHOULD USE.
C === NOTE THAT DIIS WILL SUPPRESS POPLE AND DAMPING,
C === AND THAT POPLE WILL SUPPRESS DAMPING
C
      PRCONV = ACONV
      POPLEF = .FALSE.
      DAMPF = .FALSE.
      IF (NPOPLE .LE. KCYCLS) POPLEF = .TRUE.
      IF (NDAMP .LE. KCYCLS) DAMPF = .TRUE.
C
C === DO THE ACTUAL DAMPING/EXTRAPOLATION
C
      IF (.NOT. UDIIS) THEN
      IF (POPLEF) THEN
      CALL POPLE(DC,DO,DOC,FC,FO,FOC,SC1,SC2,SC3,SPC)
      ELSE IF (DAMPF) THEN
C
C === WE WILL DAMP WITH A FIXED DAMPING COEFFICIENT ACCORDING TO THE
C === FORMULA D(NEW) = A * D(LAST) + (1 - A) * D(PREVIOUS)
C === D(NEW) WILL REPLACE D(LAST) ON THE FILE MFDENSM
C
      ALPHA = 1 - DAMPFX
      DO 300 I = 1, NBHTC
      SC1(I) = ALPHA * DC(I) + FC(I)
  300 CONTINUE
      IF (OPENSH) THEN
      DO 310 I = 1, NBHTO
      SC2(I) = ALPHA * DO(I) + FO(I)
  310 CONTINUE
      ENDIF
      IF (OPENSH.AND.NOPEN.GT.1) THEN
      DO 311 I = 1, NBHTO2
      SC3(I) = ALPHA * DOC(I) + FOC(I)
  311 CONTINUE
      ENDIF
C
C === LET'S WRITE THE NEW DENSITY MATRICES TO FILE
C
      ICTC = 1
      ICTO = 1
      ICTO2 = 1
      DO 320 IRP = 1, NSYMRP
      NBS = NBSIM (IRP) * (NBSIM (IRP) + 1) / 2
      IF (NCL(IRP) .NE. 0) THEN
      CALL WDENS(IRECDC,SC1(ICTC),NBS,IRP,1)
      ICTC = ICTC + NBS
      ENDIF
      IF (NOP(IRP,1) .NE. 0) THEN
      CALL WDENS(IRECDC,SC2(ICTO),NBS,IRP,2)
      ICTO = ICTO + NBS
      ENDIF
      IF (NOP(IRP,2) .NE. 0) THEN
      CALL WDENS(IRECDC,SC3(ICTO2),NBS,IRP,3)
      ICTO2 = ICTO2 + NBS
      ENDIF
  320 CONTINUE
      ENDIF
      ENDIF
      CLOSE(MFDENSM)
 1000 FORMAT(//' ITERATION ',I5,' :    CONVERGENCE : ',E10.2)
      RETURN
      END
