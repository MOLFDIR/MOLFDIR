
C...   Copyright (c) 1998 by the authors of Dirac (see below).
C...   All Rights Reserved.
C...
C...   The source code in this file is part of 
C...   "Dirac, a relativistic ab initio electronic structure program, 
C...   Release 3.1 (1998), written by T. Saue, T. Enevoldsen, T. Helgaker,
C...   H. J. Aa. Jensen, J. Laerdahl, K. Ruud, J. Thyssen, and L. Visscher"
C...
C...   This source code is provided under a written licence and may be 
C...   used, copied, transmitted, or stored only in accord with that
C...   written licence.
C...
C...   In particular, no part of the source code or compiled modules may 
C...   be distributed outside the research group of the licence holder. 
C...   This means also that persons (e.g. post-docs) leaving the research
C...   group of the licence holder may not take any part of Dirac,
C...   including modified files, with him/her, unless that person has
C...   obtained his/her own licence. 
C...
C...   For questions concerning this copyright write to:
C...      dirac-admin@dirac.chem.ou.dk
C...
C...   For information on how to get a licence see:
C...      http://dirac.chem.ou.dk/Dirac
C
C
C VERSION : $Revision: 1.7 $
C DATE    : $Date: 2001/09/19 00:34:50 $
C FILE    : ccdriv.F
C SOURCE  : $Source: /home/tc/visscher/sources/Molfdir/Molfdir/source/relccsd/ccdriv.F,v $
C
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCHEADER
C
      IMPLICIT REAL*8 (A-H, O-Z)
C
C---------------Description--------------------------------------------
C
C     Write header for Relativistic Coupled Cluster Program
C     Keep track of all the modifications made in the program.
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
C
C---------------Local variables--------------------------------------
C
      CHARACTER DATEX*10,TIMEX*8
C
C---------------Executable code--------------------------------------
C
      WRITE (IW,1000) "2.2 MOLFDIR edition","September 2001"
      CALL DAYTIME (DATEX,TIMEX)
      WRITE (IW,1001) DATEX,TIMEX
C
 1000 FORMAT (//" Relativistic Coupled Cluster program RELCCSD"
     &/" Version number ",A
     &/" Version date ",A
     &//" Written by :",/" Lucas (Luuk) Visscher"/
     &/" NASA Ames Research Center    (1994)"
     &/" Rijks Universiteit Groningen (1995)"
     &/" Odense Universitet           (1996-1997)" 
     &/" Vrije Universiteit Amsterdam (1998-2001)")
 1001 FORMAT (//" Today is :",T15,A10/" The time is :",T17,A8)
C
      RETURN
C---------------Record of modifications made in the code-------------
C     July 1999: Implemented Fock space Coupled Cluster
C                Parallelized (part of) the program using MPI
C--------------------------------------------------------------------
C     11-12-97 : MP2 gradients works, CCSD Lambda equations written
C--------------------------------------------------------------------
C     October 1997 : major restructuring
C     Split the code in energy, gradient and second derivative modules
C     Final version should contain energies and 1st and 2nd order
C     properties at all the available levels of theory
C     Improved memory management (thanks to H-J Aa Jensens routines)
C--------------------------------------------------------------------
C     Aug  6 1997 :  
C     Implemented excitation energy module. 
C--------------------------------------------------------------------
C     Apr 16 1997 :  
C     Interfaced with DIRAC, reorganized code. 
C--------------------------------------------------------------------
C     Jul 10 1996 :  
C     Added RPA module, changed output format, 
C     added NOCCSD (MP2) option
C     Note that the RPA is not very optimized : needs complex 
C     arithmetics for completely imaginary operators, does not
C     consider symmetry of the operators
C--------------------------------------------------------------------
C     Oct 5 1995 :  
C     Corrected errors in complex arithmetic, implemented -T correction
C     Frozen option was also implemented somewhat earlier
C--------------------------------------------------------------------
C     Aug 13 1995 :  
C     Implemented triples correction in symmetry-adapted version
C--------------------------------------------------------------------
C     Jun 29 1995 :  
C     Dynamic memory allocation & incore files for CRAY
C--------------------------------------------------------------------
C     Jan 10 1995 : 
C     Real/complex arithmetic possible
C     Symmetry packed version
C--------------------------------------------------------------------
C     Oct 19 1994 : 
C     Writes integrals out on disk
C     Otherwise identical to previous version
C--------------------------------------------------------------------
C     Sep 22 1994 : First numbered version of program 
C     Keeps all integrals in core.
C     Does not use any symmetry.
C     But is vectorized by using matrix multiplies where ever possible
C--------------------------------------------------------------------
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCINPT (IN,IW,IMIOBUF)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Reads input for relativistic Coupled Cluster program
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "inpt.inc"
      INCLUDE "complex.inc"
C
C---------------Local variables--------------------------------------
C
      LOGICAL REWINP
C
      NAMELIST/RELCCSD/ NELEC,NFROZ,CARITH,
     &                  DOSORT,DOENER,DOFOPR,DOSOPR,DOEXC,DOFSPC,
     &                  MWORD,DEBUG,TIMING,IPRNT,INTERFACE,
     &                  MIOBUF
      NAMELIST/CCSORT/ USEOE,NORECMP
      NAMELIST/CCENER/ DOMP2,DOCCSD,DOCCSDT,MAXIT,MAXDIM,NTOL
      NAMELIST/CCFOPR/ DOMP2G,DOCCSDG,DOCCSDTG,NEOPER,NAMEE,
     &                 MAXIT,MAXDIM,NTOL
      NAMELIST/CCSOPR/ NAOPER,NBOPER,NFREQ,NAMEA,NAMEB,EFREQ,
     &                 MAXIT,MAXDIM,NTOL
      NAMELIST/CCEXC / NEXC,MAXIT,MAXDIM,NTOL
      NAMELIST/CCFSPC/ FSSECT,NACTH,NACTP,NHOLE,NPART,MAXIT,MAXDIM,NTOL
      NAMELIST/CCEND / REWINP
      DOUBLE PRECISION D0
      PARAMETER (D0 = 0.0D00)
      DIMENSION NACTH(16),NACTP(16)
C
C---------------Executable code--------------------------------------
C
C     Read number of occupied spinors from input
C
      OPEN (5,FILE='MOLFDIR.INP', FORM='FORMATTED')
      ITEST = 0
      MIOBUF = 0
      REWIND (5)
      DO I = 1, 16
         NFROZ(I) = 0
      ENDDO
      IPRNT = 0
      DOSORT  = .TRUE.
      DOENER  = .TRUE.
      DOFOPR  = .FALSE.
      DOSOPR  = .FALSE.
      DOEXC   = .FALSE.
      DOFSPC  = .FALSE.
      DEBUG  = .FALSE.
      TIMING = .FALSE.
      MWORD = 0
      CALL LOCATE('RELCCSD',7,ITEST)
      print*,'locate relccsd',itest
      IF (ITEST.GT.0) THEN
         READ(5,RELCCSD,ERR=1)
      ELSE
         GOTO 1
      ENDIF
      IMIOBUF = MIOBUF
      GOTO 2
    1 CALL QUIT('Error exit while reading namelist RELCCSD')
    2 CONTINUE
C
C     Input for the energy calculation.
C
      MAXDIM = 8
      MAXIT = 30
      NTOL = 12
      DOMP2   = .TRUE.
      DOCCSD  = .FALSE.
      DOCCSDT = .FALSE.
      REWIND (5)
      CALL LOCATE('CCENER',6,ITEST)
      IF (ITEST.GT.0) READ(5,CCENER,ERR=3)
      GOTO 4
    3 CALL QUIT('Error exit while reading namelist CCENER')
    4 CONTINUE
      MXDIMCC = MAXDIM
      MXITCC = MAXIT
      NTOLCC = NTOL
C
C     Input for the gradient calculation.
C
      DOMP2G   = .FALSE.
      DOCCSDG  = .FALSE.
      DOCCSDTG = .FALSE.
      NEOPER = 1
      NAMEE(1) = 'ZDIPLEN '
      MAXDIM = 8
      MAXIT = 30
      NTOL = 12
      REWIND (5)
      CALL LOCATE('CCFOPR',6,ITEST)
      IF (ITEST.GT.0) THEN
         READ(5,CCFOPR,ERR=5)
      ELSE
         GOTO 6
      ENDIF
      GOTO 6
    5 CALL QUIT('Error exit while reading namelist CCFOPR')
    6 CONTINUE
      MXDIMGR = MAXDIM
      MXITGR = MAXIT
      NTOLGR = NTOL
C
C     Input for the linear response calculation.
C
      NAOPER = 1
      NBOPER = 1
      NFREQ = 1
      DO I = 1, 16
         NEXC(I) = 1
      ENDDO
      NAMEA(1) = 'ZDIPLEN '
      NAMEB(1) = 'ZDIPLEN '
      DO IFREQ = 1, MAXFR
         EFREQ(IFREQ) = D0
      ENDDO
      MAXDIM = 8
      MAXIT = 30
      NTOL = 12
      REWIND (5)
      CALL LOCATE('CCSOPR',6,ITEST)
      IF (ITEST.GT.0) THEN
         READ(5,CCSOPR,ERR=7)
      ELSE
         GOTO 8
      ENDIF
      GOTO 8
    7 CALL QUIT('Error exit while reading namelist CCSOPR')
    8 CONTINUE
      MXDIMRP = MAXDIM
      MXITRP = MAXIT
      NTOLRP = NTOL
C
C     Input for the excitation energy calculation.
C
      DO I = 1, 16
         NEXC(I) = 1
      ENDDO
      MAXDIM = 8
      MAXIT = 30
      NTOL = 12
      REWIND (5)
      CALL LOCATE('CCEXC',5,ITEST)
      IF (ITEST.GT.0) THEN
         READ(5,CCEXC,ERR=9)
      ELSE
         GOTO 10
      ENDIF
      GOTO 10
    9 CALL QUIT('Error exit while reading namelist CCEXC')
   10 CONTINUE
      MXDIMEX = MAXDIM
      MXITEX = MAXIT
      NTOLEX = NTOL
C
C     Input for the Fock-Space CCSD energy calculation.
C
      MAXDIM = 8
      MAXIT = 30
      NTOL = 12
      DO I = 1, 16
         NACTH(I) = 0
         NACTP(I) = 0
         NHOLE(I) = 0
         NPART(I) = 0
      ENDDO
      DO ISECT = 1, 6
         FSSECT(ISECT) = 0
      ENDDO
      REWIND (5)
      CALL LOCATE('CCFSPC',6,ITEST)
      IF (ITEST.GT.0) THEN
         READ (5,CCFSPC,ERR=11)
      ELSE
         GOTO 12
      ENDIF
      GOTO 12
   11 CALL QUIT('Error exit while reading namelist CCFSPC')
   12 CONTINUE
      MXDIMFS = MAXDIM
      MXITFS = MAXIT
      NTOLFS = NTOL
      DO I = 1, 16
         NINACT(I) = NELEC(I) - NACTH(I)
         NACT(I) = NACTH(I) + NACTP(I)
      ENDDO
C
C     Input for the sorting routine.
C
      USEOE = .FALSE.
      NORECMP = .FALSE.
      REWIND (5)
      CALL LOCATE('CCSORT',6,ITEST)
      IF (ITEST.GT.0) THEN
         READ(5,CCSORT,ERR=13)
      ELSE
         GOTO 14
      ENDIF
      GOTO 14
   13 CALL QUIT('Error exit while reading namelist CCSORT')
   14 CONTINUE
C
C     Position the file at the right spot when this routine is
C     called as a part of DIRAC
C
      REWIND (5)
      REWINP = .FALSE.
      CALL LOCATE('CCEND',5,ITEST)
      IF (ITEST.GT.0) THEN
         READ(5,CCEND,ERR=99)
      ELSE
         GOTO 100
      ENDIF
      GOTO 100
   99 CALL QUIT('Error exit while reading namelist CCEND')
  100 CONTINUE
      IF (REWINP) REWIND (5)
C
      RETURN
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
#if defined (CRAY) || defined (IBM) || defined (SGI) || defined (HP9) || defined (SUN)
      SUBROUTINE CCMAIN (MAXCORE,IUNIN,IUNUT,CA,INTFCE)
#else
      SUBROUTINE CCMAIN (MAXCORE,CC,IUNIN,IUNUT,CA,INTFCE)
#endif
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Driver for Relativistic Coupled Cluster program
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "iobuf.inc"
      INCLUDE "diis.inc"
      INCLUDE "inpt.inc"
      INCLUDE "symm.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
#if defined (VAR_MPI)
      INCLUDE 'mpif.h'
      DIMENSION ISTAT(MPI_STATUS_SIZE)
#endif
C
C---------------Local variables--------------------------------------
C
C     CC is the static memory  (when called as subroutine)
C     CC is the dynamic memory (when used as stand-alone code)
C
C
#if defined (CRAY) || defined (IBM) || defined (SGI) || defined (HP9) || defined (SUN)
      POINTER (ICC,CC(1))
      REAL*8 CC
#else
      REAL*8 CC(MAXCORE)
#endif
      PARAMETER (MAXSP=1000)
      INTEGER IREPSP(MAXSP*4),IREPSPI(MAXSP*16*2)
      REAL*8 EPS(MAXSP),EPS1(MAXSP)
      LOGICAL ALLOC,CA
      REAL*8 CPU0,CPU1,CPU2,CPUTOT,CPUI,CPUE,CPUS,CPUFO,CPUSO,CPUVAR
      CHARACTER*10 INTFCE
C
C---------------Executable code--------------------------------------
C
C     Set the input and output units
C
      INTERFACE = INTFCE
      CARITH = CA
      IN = IUNIN
      IW = IUNUT
      WRITE (IW,1011) MYPROC+1,NMPROC

C
      if (myproc.eq.master) CALL CCHEADER
C
C     Initialize the timing.
C
      CALL XTIME(1,0,' ')
      CALL CPUUSED(CPU0)
      CPU1 = CPU0
      CPUI = 0
      CPUS = 0
      CPUE = 0
      CPUFO = 0
      CPUSO = 0
      CPUTOT = 0
C
C     Memory and I/O setup section
C     ----------------------------
C
      MAXCOR = MAXCORE
      MXCORR = 0
C
C     Read symmetry information
C
      CALL RDSYMI (NSP,EPS1,IREPSP)
C
      IF (NSP.GT.MAXSP) THEN
         PRINT*," INCREASE MAXSP IN CCMAIN TO",NSP
         CALL QUIT("NSP.GT.MAXSP")
      ENDIF
C
C     Read input
C
      CALL CCINPT (IN,IW,MIOBUF)
C
C     Number of integer words for REAL*8 and 
C     number of REAL*8 words per variable (2 for complex groups, 
C     1 for real)
C
      IRW = INTOWP(1)
      IF (CARITH) THEN
         RCW = 2
      ELSE
         RCW = 1
      ENDIF
C
      IF (MWORD.GT.0) MAXCOR = MWORD * 1024 * 1024
      MWORD = MAXCOR / (1024 * 1024)
      IF (MOD(MAXCOR,1024*1024).NE.0) MWORD = MWORD + 1
C
C  Check the user supplied memory limit with the static maximum.
C
      IERR = 0
#if defined (CRAY) || defined (IBM) || defined (SGI) || defined (HP9) || defined (SUN)
C  No static check needed
#else 
      IF ((MWORD*1024*1024).GT.MAXCORE) IERR=1
#endif
      IF (IERR.NE.0) THEN
         MWORD = MAXCORE / (1024 * 1024)
         if (myproc.eq.master) WRITE (IW,1006) MAXCORE,MWORD
         CALL QUIT("DECREASE MWORD")
      ENDIF
C
C     In case of dynamic allocation :
C     Allow for overhead : subtract 800 kWord
C     Allow for file buffers (Cray only) : NCCFIL files with 20 blocks each
C
         MAXCOR = MAXCOR - 800 * 1024
#if defined (CRAY) 
         MAXCOR = MAXCOR - NCCFIL * 20 * 512
#endif
C
      if (myproc.eq.master) WRITE (IW,1000) MAXCOR
C
C  Calculate minimum size of I/O buffers 
C  Records defined in integer*4 words, minimum size is one record
C
      NREC = 1
      MINBUF = SEC2I(NREC)
      MINSEC = IRW * RCW * NREC
C
      if (myproc.eq.master) WRITE (IW,1005) MINBUF*RCW
C
C     General setup
C     -------------
C
      CALL CCDINI
C
C     Set up symmetry tables and parallel distribution arrays
C     -------------------------------------------------------
C
      CALL SYMTAB (NELEC,NFROZ,NINACT,NACT,NSP,EPS1,EPS,IREPSP,IREPSPI,
     &             .FALSE.,.TRUE.)
C
      NELECT = 0
      DO I = 1, 16
         NELECT = NELECT + NELEC(I)
      ENDDO
C
      if (myproc.eq.master) 
     &WRITE (IW,1004) NELECT,NSP-NELECT,CARITH,DOSORT,DOENER,DOFOPR,
     &                DOSOPR,DOEXC,DEBUG,TIMING,IPRNT,MWORD,INTERFACE
C     
C     Check whether the Fock space CC module is included in this version
C
      IF (DOFSPC) THEN
         CALL QUIT('FOCK SPACE CC NOT AVAILABLE IN THIS VERSION')
      ENDIF
C
C     Check the memory requirements of the active modules
C     ---------------------------------------------------
C
      ICALC = 1
      ALLOC = .FALSE.
      KFREE = 1
      LFREE = MAXCOR
C 
      MXCORR1 = 0
      CALL CCSETI (ICALC,CC,KFREE,LFREE,MXCORR1,MREMAIN,EPS,
     &             NSP,IREPSP,IREPSPI)
      IF (DOSORT) MXCORR = MAX0(MXCORR,MXCORR1)
C     WRITE(IW,1015) 'CCSETI',MXCORR1,MXCORR

      MXCORR1 = 0
      CALL CCENER (ICALC,CC,KFREE,LFREE,MXCORR1,EPS)
      IF (DOENER) MXCORR = MAX0(MXCORR,MXCORR1)
C     WRITE(IW,1015) 'CCENER',MXCORR1,MXCORR
C
      MXCORR1 = 0
      CALL CCFOPR (ICALC,NSP,IREPSPI,CC,KFREE,LFREE,MXCORR1,EPS)
      IF (DOFOPR) MXCORR = MAX0(MXCORR,MXCORR1)
C
      MXCORR1 = 0
      CALL CCHESS (ICALC,CC,KFREE,LFREE,MXCORR1,EPS,NSP,IREPSPI)
      IF (DOSOPR) MXCORR = MAX0(MXCORR,MXCORR1)
C
      MXCORR1 = 0
      CALL CCEXC (ICALC,CC,KFREE,LFREE,MXCORR1,EPS,NSP,IREPSPI)
      IF (DOEXC) MXCORR = MAX0(MXCORR,MXCORR1)
C
      MXCORR1 = 0
      CALL CCFSPC(ICALC,CC,KFREE,LFREE,MXCORR1,EPS1,EPS,NSP,
     &            IREPSP,IREPSPI,MREMAIN)
      IF (DOFSPC) MXCORR = MAX0(MXCORR,MXCORR1)
C
C MXCORR is a cumulative maximum of individual memory requirements
C and MAXCOR is the fixed maximum of core memory available on this
C node. ===> if any subroutine would need more core memory we quit.

      IF (MXCORR.GT.MAXCOR) THEN
         MXCORR = MXCORR+800*1024
#if defined (CRAY) 
         MXCORR = MXCORR+NCCFIL*20*512
#endif
         MWORD = MXCORR / (1024 * 1024)
         IF (MOD(MXCORR,1024*1024).NE.0) MWORD = MWORD + 1
         if (myproc.eq.master) WRITE (IW,1002) MXCORR,MWORD
         CALL FLSHFO (IW)
         CALL QUIT("INCREASE MWORD")
      ENDIF
C
C  Allocate the memory and check if it is a standalone version
C
      IERR = 0
      IABORT = 0
#if defined (CRAY) 
      CALL HPALLOC (ICC,MXCORR,IERR,IABORT)
#endif
#if defined (IBM)
      ICC =  MALLOC (%VAL(MXCORR*8))
      IF (ICC.EQ.0) IERR = 1
#endif
#if defined (SGI) || defined (HP9)
      ICC =  MALLOC (MXCORR*8)
      IF (ICC.EQ.0) IERR = 1
#endif
      IF (IERR.NE.0) THEN
          PRINT*, " Problems allocating ",MXCORR," words"
          CALL QUIT("MEMORY PROBLEMS")
      ENDIF
C
      if (myproc.eq.master) WRITE (IW,1001) MXCORR
C
C  Use remaining free memory as extra buffer for integral and
C  coefficient files.
C  At present only used in Cray version.
C
      MREMAIN = MAXCOR - MXCORR
      CALL CPUUSED(CPU2)
      CPUI = CPUI + CPU2 - CPU1
      CPU1 = CPU2
C
C     Start the calculations
C     ----------------------
C
      ICALC = 2
      ALLOC = .TRUE.
      KFREE = 1
      LFREE = MXCORR
C
      CALL XTIME(1,1,'Sorting of integrals          ')
      IF (DOSORT) CALL CCSETI (ICALC,CC,KFREE,LFREE,MXCORR,MREMAIN,EPS,
     &            NSP,IREPSP,IREPSPI)
      CALL XTIME(1,2,'Sorting of integrals          ')
      CALL CPUUSED(CPU2)
      CPUS = CPUS + CPU2 - CPU1
      CPU1 = CPU2
      CALL FLSHFO (IW)
C
      IF (DOENER) CALL CCENER (ICALC,CC,KFREE,LFREE,MXCORR,EPS)
      CALL CPUUSED(CPU2)
      CPUE = CPUE + CPU2 - CPU1
      CPU1 = CPU2
      CALL FLSHFO (IW)
C
      IF (DOFOPR) CALL CCFOPR (ICALC,NSP,IREPSPI,CC,KFREE,LFREE,
     &            MXCORR,EPS)
      CALL CPUUSED(CPU2)
      CPUFO = CPUFO + CPU2 - CPU1
      CPU1 = CPU2
      CALL FLSHFO (IW)
C
      IF (DOSOPR) CALL CCHESS (ICALC,CC,KFREE,LFREE,MXCORR,EPS,
     &                         NSP,IREPSPI)
      CALL CPUUSED(CPU2)
      CPUSO = CPUSO + CPU2 - CPU1
      CPU1 = CPU2
      CALL FLSHFO (IW)
C
      IF (DOEXC ) CALL CCEXC (ICALC,CC,KFREE,LFREE,MXCORR,EPS,
     &                        NSP,IREPSPI)
      CALL FLSHFO (IW)
C
      IF (DOFSPC) CALL CCFSPC(ICALC,CC,KFREE,LFREE,MXCORR,EPS1,EPS,
     &                         NSP,IREPSP,IREPSPI,MREMAIN)
      CALL FLSHFO (IW)
C
C  FINISHED; RETURN AFTER CLOSING FILES
C
      JCODE = 4
      CALL RCLOSE(ITAPT+0,JCODE)
      JCODE = 4
      CALL RCLOSE(ITAPT+1,JCODE)
      JCODE = 4
      CALL RCLOSE(ITAPT+2,JCODE)
      JCODE = 4
      CALL RCLOSE(ITAPT+3,JCODE)
      JCODE = 4
      CALL RCLOSE(ITAPT+4,JCODE)
      JCODE = 4
      IF (DOCCSD.OR.DOCCSDT) CALL RCLOSE(ITAPT+5,JCODE)
      JCODE = 4
      IF (DOCCSD) CALL RCLOSE(ITAPT+6,JCODE)
C
      CALL CCSUMM
      CALL FLSHFO (IW)
C   
C     Print timings (second XTIME parameter has to be 4)
C
      CALL XTIME(1,4,' ')
      CALL FLSHFO (IW)
      CALL CPUUSED(CPUTOT)
      CPUTOT = CPUTOT-CPU0
      CPUVAR = CPUTOT-CPUI-CPUS-CPUE-CPUFO-CPUSO
      if (myproc.eq.master) 
     &WRITE(IW,1010) CPU0,CPUI,CPUS,CPUE,CPUFO,CPUSO,CPUVAR,CPUTOT
      CALL FLSHFO (IW)
C
      RETURN
C
1000  FORMAT (/" Maximum core available :",T50,I10," 8-byte words")
1001  FORMAT (" Maximum core used for active modules :",
     &        T50,I10," 8-byte words")
1002  FORMAT (" Not enough core, increase to at least",
     &        T50,I10," 8-byte words"//" Make Mword equal to ",I5)
1003  FORMAT (/" Size of 3- and 4-virtual batches :",T50,I10
     &        /" Number of passes :",T50,I10)
1004  FORMAT (//" Number of electrons :",T40,I5
     &        /" Number of virtual spinors :",T40,I5
     &        /" Complex arithmetic mode :",T44,L1
     &        /" Do integral sorting     :",T44,L1
     &        /" Do energy calculation   :",T44,L1
     &        /" Do gradient calculation :",T44,L1
     &        /" Do response calculation :",T44,L1
     &        /" Calculate exc. energies :",T44,L1
     &        /" Debug information       :",T44,L1
     &        /" Timing information      :",T44,L1
     &        /" Print level          :",T40,I5
     &        /" Memory limit (MWord) :",T40,I5
     &        /" Interface used       :",T40,A10//)
1005  FORMAT (" Size of I/O buffers :",T50,I10," 8-byte words")
1006  FORMAT (" Too much core specified, maximum is",
     &        T50,I10," 8-byte words"//" Make Mword equal to ",I5,
     &        //"Or increase MAXCORE !!")
1008  FORMAT (" Amount of memory used :",T50,F10.1," megawords")
1010  FORMAT(//' Timing of main modules :'
     &/' Before CC driver :',T30,F12.3,' seconds'
     &/' Initialization :',T30,F12.3,' seconds'
     &/' Integral sorting :',T30,F12.3,' seconds'
     &/' Energy calculation :',T30,F12.3,' seconds'
     &/' First order properties :',T30,F12.3,' seconds'
     &/' Second order properties :',T30,F12.3,' seconds'
     &/' Untimed parts :',T30,F12.3,' seconds'
     &/' Total time in CC driver :',T30,F12.3,' seconds')
 1011 FORMAT (/'---< Process ',I5,' of ',I5,'----<'/)
 1015 FORMAT (/' Checking ',A,'MXCORR1,MXCORR',2I10)
C
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE SYMTAB (NELEC,NFROZ,NINACT,NACT,
     &                   NSP,EPS1,EPS,IREPSP,IREPSPI,FOCKSP,REPORT)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Generate symmetry pointer arrays
C
C---------------Routines called----------------------------------------
C
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
      INTEGER IREPSP(NSP,4),IREPSPI(NSP,16,2)
      INTEGER NELEC(16),NFROZ(16),NINACT(16),NACT(16)
      REAL*8 EPS1(*),EPS(*)
      LOGICAL FOCKSP,REPORT
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "param.inc"
      INCLUDE "files.inc"
      INCLUDE "symm.inc"
      INCLUDE "freeze.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
C
C---------------Local variables--------------------------------------
C
      CHARACTER*14 REPNT(16)
      INTEGER NVIRT(16)
      INTEGER NOOOT2(MXREP),NVVVT2(MXREP)
C
C---------------Executable code--------------------------------------
C
C     Initialize dimension arrays
C
      DO IREP = 1, NREP
         NE(IREP) = 0
         NO(IREP) = 0
         NV(IREP) = 0
         NC(IREP) = 0
         NIO(IREP) = 0
         NIV(IREP) = 0
         NAO(IREP) = 0
         NAV(IREP) = 0
         NSO(IREP) = 0
         NSV(IREP) = 0
         MOO(IREP) = 0
         MVO(IREP) = 0
         MVV(IREP) = 0
         NOO(IREP) = 0
         NOV(IREP) = 0
         NVO(IREP) = 0
         NVV(IREP) = 0
         NOOT(IREP) = 0
         NVVT(IREP) = 0
         NOOOT(IREP) = 0
         NVOOT(IREP) = 0
         NVVOT(IREP) = 0
         NOOVT(IREP) = 0
         NVVVT(IREP) = 0
         NVOO (IREP) = 0
         NOVO (IREP) = 0
         NOVVT(IREP) = 0
         NOOOT2(IREP) = 0
         NVVVT2(IREP) = 0
C ** additional arrays for parallel triples
         NT3VVT(IREP) = 0
         NT3VVVT(IREP) = 0
      ENDDO
C
C     Convert input information to abelian subgroup
C
      IF (.NOT.FOCKSP) THEN
C
C     Single reference calculation : we need only to distinguish
C     between occupied and virtual, no active orbitals.
C
         NFROZEN = 0
         DO IRP = 1, NSYMRP
            NVIRT(IRP) = 0
            IN  = 0
            DO I = 1, NSP
               IF (IREPSP(I,1).EQ.IRP) THEN
                  IN = IN + 1
                  IREP = IREPSP(I,2)
                  IF (IN.LE.NELEC(IRP)) THEN
                     NO(IREP) = NO(IREP) + 1
                     IREPSP(I,3) = NO(IREP)
                     IREPSPI(NO(IREP),IREP,1) = I
                     IF (NO(IREP).GT.MAXFROZ) 
     &                  CALL QUIT("INCREASE MAXFROZ")
                     IF (IN.LE.NFROZ(IRP)) THEN
                        NC(IREP) = NC(IREP) + 1
                        IFROZ(NO(IREP),IREP) =  NC(IREP)
                        NFROZEN = NFROZEN + 1
                     ELSE
                        IFROZ(NO(IREP),IREP) =  0
                     ENDIF
                  ELSE
                     NVIRT(IRP) = NVIRT(IRP) + 1
                     NV(IREP) = NV(IREP) + 1
                     IREPSP(I,3) = - NV(IREP)
                     IREPSPI(NV(IREP),IREP,2) = I
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
C
         DO IREP = 1, NREP
C           The number of electrons is now identical to NO, but we need
C           two separate arrays because NO is extended in case of
C           Fock space calculations (see below).
            NE(IREP) = NO(IREP)
C           Fill in the Fock space arrays in case we call a routine that
C           needs them.
            NIO(IREP) = NO(IREP)
            NAO(IREP) = 0
            NIV(IREP) = NV(IREP)
            NAV(IREP) = 0
            NSO(IREP) = NO(IREP)
            NSV(IREP) = NV(IREP)
         ENDDO
C
      ELSE ! Fockspace
C
C     Active spinors belong to both the occupied and virtual
C     space in Fock space calculations. We need a different sorting
C     that puts all the active occupied at the end of the occupied set
C     and all the active virtuals in the beginning. This may break the
C     original (higher pointgroup) symmetry ordering but keeps the
C     Abelian order.
C
C        Step 1 - Add the inactive occupied to the O space
C               - Add the active virtual to the V space
C
         NFROZEN = 0
         DO IRP = 1, NSYMRP
            NVIRT(IRP) = 0
            IN  = 0
            DO I = 1, NSP
               IF (IREPSP(I,1).EQ.IRP) THEN
                  IN = IN + 1
                  IREP = IREPSP(I,2)
                  IF (IN.LE.NELEC(IRP).AND.
     &                IN.LE.NINACT(IRP)) THEN
                     NIO(IREP) = NIO(IREP) + 1
                     NO(IREP) = NO(IREP) + 1
                     IREPSP(I,3) = NO(IREP)
                     IREPSP(I,4) = IREPSP(I,3)
                     IREPSPI(NO(IREP),IREP,1) = I
C                    Check for frozen core orbitals
                     IF (NO(IREP).GT.MAXFROZ) 
     &                  CALL QUIT("INCREASE MAXFROZ")
                     IF (IN.LE.NFROZ(IRP)) THEN
                        NC(IREP) = NC(IREP) + 1
                        IFROZ(NO(IREP),IREP) =  NC(IREP)
                        NFROZEN = NFROZEN + 1
                     ELSE
                        IFROZ(NO(IREP),IREP) =  0
                     ENDIF
                  ENDIF
                  IF (IN.GT.NELEC(IRP).AND.
     &                IN.LE.NACT(IRP)+NINACT(IRP)) THEN
                     NVIRT(IRP) = NVIRT(IRP) + 1
                     NAV(IREP) = NAV(IREP) + 1
                     NV(IREP) = NV(IREP) + 1
                     IREPSP(I,3) = - NV(IREP)
                     IREPSPI(NV(IREP),IREP,2) = I
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
C
C        Step 2 - Add the active occupied to the O space
C               - Add the inactive virtual to the V space
C
         DO IRP = 1, NSYMRP
            IN  = 0
            DO I = 1, NSP
               IF (IREPSP(I,1).EQ.IRP) THEN
                  IN = IN + 1
                  IREP = IREPSP(I,2)
                  IF (IN.LE.NELEC(IRP).AND.
     &                IN.GT.NINACT(IRP)) THEN
                     NAO(IREP) = NAO(IREP) + 1
                     NO(IREP) = NO(IREP) + 1
                     IREPSP(I,3) = NO(IREP)
                     IREPSPI(NO(IREP),IREP,1) = I
                     IFROZ(NO(IREP),IREP) =  0 ! No frozen act. allowed
                  ENDIF
                  IF (IN.GT.NELEC(IRP).AND.
     &                IN.GT.NACT(IRP)+NINACT(IRP)) THEN
                     NVIRT(IRP) = NVIRT(IRP) + 1
                     NIV(IREP) = NIV(IREP) + 1
                     NV(IREP) = NV(IREP) + 1
                     IREPSP(I,3) = - NV(IREP)
                     IREPSP(I,4) = IREPSP(I,3)
                     IREPSPI(NV(IREP),IREP,2) = I
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
C
C        Step 3 - Add the active occupied also to the V space
C               - Add the active virtual also to the O space
C
         DO IRP = 1, NSYMRP
            IN  = 0
            DO I = 1, NSP
               IF (IREPSP(I,1).EQ.IRP) THEN
                  IN = IN + 1
                  IREP = IREPSP(I,2)
                  IF (IN.LE.NELEC(IRP).AND.
     &                IN.GT.NINACT(IRP)) THEN
                     NV(IREP) = NV(IREP) + 1
                     IREPSP(I,4) = - NV(IREP)
                     IREPSPI(NV(IREP),IREP,2) = I
                  ENDIF
                  IF (IN.GT.NELEC(IRP).AND.
     &                IN.LE.NACT(IRP)+NINACT(IRP)) THEN
                     NO(IREP) = NO(IREP) + 1
                     IREPSP(I,4) = NO(IREP)
                     IREPSPI(NO(IREP),IREP,1) = I
                     IFROZ(NO(IREP),IREP) =  0 ! No frozen act. allowed
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
C
C        The total numbers of occupied/virtual, regardless of act/inact
C
         DO IREP = 1, NREP
            NSO(IREP) = NIO(IREP) + NAO(IREP)
            NSV(IREP) = NIV(IREP) + NAV(IREP)
            NE(IREP)  = NSO(IREP)
         ENDDO
      ENDIF
C
      IF (REPORT.AND.(.NOT.FOCKSP).and.(myproc.eq.master)) THEN
         WRITE (IW,1000) (REPN(I),I=1,NSYMRP)
         WRITE (IW,1002) 'occupied',(NELEC(I),I=1,NSYMRP)
         WRITE (IW,1002) 'virtual ',(NVIRT(I),I=1,NSYMRP)
         IF (SPFR) THEN
            NREP1 = 1
            NREP2 = MIN0(NREP/2,8)
  10        WRITE (IW,1001) (REPNA(I),I=NREP1,NREP2)
            WRITE (IW,1002) 'occupied',(NO(I),I=NREP1,NREP2)
            WRITE (IW,1002) 'virtual ',(NV(I),I=NREP1,NREP2)
            NREP1 = NREP1 + 8
            NREP2 = MIN0(NREP/2,NREP2+8)
            IF (NREP1.LE.NREP/2) GOTO 10
         ELSE
            WRITE (IW,1001) (REPNA(I),I=1,NREP)
            WRITE (IW,1002) 'occupied',(NO(I),I=1,NREP)
            WRITE (IW,1002) 'virtual ',(NV(I),I=1,NREP)
         ENDIF
      ENDIF
C
      IF (NFROZEN.GT.0.AND.REPORT.and.(myproc.eq.master)) THEN
         WRITE (IW,1003)
         WRITE (IW,1000) (REPN(I),I=1,NSYMRP)
         WRITE (IW,1002) 'frozen',(NFROZ(I),I=1,NSYMRP)
         WRITE (IW,1001) (REPNA(I),I=1,NREP)
         WRITE (IW,1002) 'frozen',(NC(I),I=1,NREP)
      ENDIF
C
      IF (FOCKSP.AND.REPORT.and.(myproc.eq.master)) THEN
         WRITE (IW,1004)
         WRITE (IW,1000) (REPN(I),I=1,NSYMRP)
         WRITE (IW,1002) 'inactive occupied',(NINACT(I),I=1,NSYMRP)
         WRITE (IW,1002) 'active occupied  ',
     &                   (NELEC(I)-NINACT(I),I=1,NSYMRP)
         WRITE (IW,1002) 'active virtual   ',
     &                   (NINACT(I)+NACT(I)-NELEC(I),I=1,NSYMRP)
         WRITE (IW,1002) 'inactive virtual ',(NELEC(I)+NVIRT(I)-
     &                    NINACT(I)-NACT(I),I=1,NSYMRP)
         IF (SPFR) THEN
            NREP1 = 1
            NREP2 = MIN0(NREP/2,8)
   11       WRITE (IW,1001) (REPNA(I),I=NREP1,NREP2)
            WRITE (IW,1002) 'inactive occupied',(NIO(I),I=NREP1,NREP2)
            WRITE (IW,1002) 'active occupied  ',(NAO(I),I=NREP1,NREP2)
            WRITE (IW,1002) 'active virtual   ',(NAV(I),I=NREP1,NREP2)
            WRITE (IW,1002) 'inactive virtual ',(NIV(I),I=NREP1,NREP2)
            NREP1 = NREP1 + 8
            NREP2 = MIN0(NREP/2,NREP2+8)
            IF (NREP1.LE.NREP/2) GOTO 11
          ELSE
            WRITE (IW,1001) (REPNA(I),I=1,NREP)
            WRITE (IW,1002) 'inactive occupied',(NIO(I),I=1,NREP)
            WRITE (IW,1002) 'active occupied  ',(NAO(I),I=1,NREP)
            WRITE (IW,1002) 'active virtual   ',(NAV(I),I=1,NREP)
            WRITE (IW,1002) 'inactive virtual ',(NIV(I),I=1,NREP)
         ENDIF
      ENDIF
C
C
C     Set up dimension arrays
C
      DO JREP = 1, NREP
         DO IREP = 1, NREP
            IJREP = MULTB(IREP,JREP,1)
            IIOV(IREP,JREP) = NOV(IJREP)
            IIVO(IREP,JREP) = NVO(IJREP)
            IIVV(IREP,JREP) = NVV(IJREP)
            NOO(IJREP) = NOO(IJREP) + NO(IREP)*NO(JREP)
            NOV(IJREP) = NOV(IJREP) + NO(IREP)*NV(JREP)
            NVO(IJREP) = NVO(IJREP) + NV(IREP)*NO(JREP)
            NVV(IJREP) = NVV(IJREP) + NV(IREP)*NV(JREP)
            IJREP = MULTB(IREP,JREP,2)
            JJOO(IREP,JREP) = MOO(IJREP)
            JJVO(IREP,JREP) = MVO(IJREP)
            JJVV(IREP,JREP) = MVV(IJREP)
            MOO(IJREP) = MOO(IJREP) + NO(IREP)*NO(JREP)
            MVO(IJREP) = MVO(IJREP) + NV(IREP)*NO(JREP)
            MVV(IJREP) = MVV(IJREP) + NV(IREP)*NV(JREP)
         ENDDO
      ENDDO
C
      DO JREP = 1, NREP
         IJREP = MULTB(JREP,JREP,1)
         IIOOT(JREP,JREP) = NOOT(IJREP)
         IIVVT(JREP,JREP) = NVVT(IJREP)
         NOOT(IJREP) = NOOT(IJREP) + NO(JREP)*(NO(JREP)-1)/2
         NVVT(IJREP) = NVVT(IJREP) + NV(JREP)*(NV(JREP)-1)/2
         DO IREP = JREP + 1, NREP
            IJREP = MULTB(IREP,JREP,1)
            IIOOT(IREP,JREP) = NOOT(IJREP)
            IIVVT(IREP,JREP) = NVVT(IJREP)
            NOOT(IJREP) = NOOT(IJREP) + NO(IREP)*NO(JREP)
            NVVT(IJREP) = NVVT(IJREP) + NV(IREP)*NV(JREP)
         ENDDO
      ENDDO
C
      DO KREP = 1, NREP
         DO IJREP = 1, NREP
            IJKREP = MULTB(KREP,IJREP+NREP,2)
            KKOOOT(IJREP,KREP) = NOOOT(IJKREP)
            KKVVOT(IJREP,KREP) = NVVOT(IJKREP)
            KKOOVT(IJREP,KREP) = NOOVT(IJKREP)
            KKVOO (IJREP,KREP) = NVOO (IJKREP)
            NOOOT(IJKREP) = NOOOT(IJKREP) + NOOT(IJREP)*NO(KREP)
            NVVOT(IJKREP) = NVVOT(IJKREP) + NVVT(IJREP)*NO(KREP)
            NOOVT(IJKREP) = NOOVT(IJKREP) + NOOT(IJREP)*NV(KREP)
            NVVVT(IJKREP) = NVVVT(IJKREP) + NVVT(IJREP)*NV(KREP)
            NVOO (IJKREP) = NVOO (IJKREP) + NVO (IJREP)*NO(KREP)
         ENDDO
      ENDDO
C
      DO IJREP = 1, NREP
         DO KREP = 1, NREP
            IJKREP = MULTB(KREP,IJREP+NREP,2)
            LLOVO (KREP,IJREP) = NOVO (IJKREP)
            LLVOOT(KREP,IJREP) = NVOOT(IJKREP)
            LLOVVT(KREP,IJREP) = NOVVT(IJKREP)
            LLOOOT(KREP,IJREP) = NOOOT2(IJKREP)
            LLVVVT(KREP,IJREP) = NVVVT2(IJKREP)
            NOVO (IJKREP) = NOVO (IJKREP) + NVO(IJREP)*NO(KREP)
            NVOOT(IJKREP) = NVOOT(IJKREP) + NOOT(IJREP)*NV(KREP)
            NOVVT(IJKREP) = NOVVT(IJKREP) + NVVT(IJREP)*NO(KREP)
            NOOOT2(IJKREP) = NOOOT2(IJKREP) + NOOT(IJREP)*NO(KREP)
            NVVVT2(IJKREP) = NVVVT2(IJKREP) + NVVT(IJREP)*NV(KREP)
         ENDDO
      ENDDO
C
C set up number of Fock matrix elements NFOO, NFVO, NFVV
C and maximum number of amplitudes NDIMT1, NDIMT2
C
      NFOO = MOO(1)
      NFVO = MVO(1)
      NFVV = MVV(1)
      NDIMT1 = 0
      NDIMT2 = 0
      DO IREP = 1, NREP
         NDIMT1 = NDIMT1 + NV(IREP)*NO(IREP)
         NDIMT2 = NDIMT2 + NVVT(IREP)*NOOT(IREP)
      ENDDO
C
C     Set up pointer arrays : IXXXX for <IJ,KL:KLREP> ordening
C                             JXXXX for (IK|JL:JLREP) ordening
C                             KXXXX for <IJK,L:LREP> ordening
C                             LXXXX for <I,JKL:JKLREP> ordening
C
      IO(1) = 0
      IV(1) = 0
C
      DO IREP = 1, NREP
         IO(IREP+1) = IO(IREP) + NO(IREP)
         IV(IREP+1) = IV(IREP) + NV(IREP)
      ENDDO
C
      IOO(1) = 0
      IVO(1) = 0
      IVV(1) = 0
      IOOOOTT(1) = 0
      IVOOOT (1) = 0
      IVVOOTT(1) = 0
      IVOVO  (1) = 0
      IVOVVT (1) = 0
      IVVVVTT(1) = 0
      IVVOO  (1) = 0
      IVVOOT (1) = 0
C
C setting up the totally symmetric XXXX arrays. IMPORTANT:
C if we look at <VV||VV> the product of all four ireps has to be
C totally symmetric. due to construction the NXX(T) arrays are either
C starred or unstarred and the product NXX(T) * NXX(T) always corresponds
C to GAMMA* * GAMMA = A only in ABELIAN symmetries !!!
C so a further distinction and check for total symmetry is not necessary !!
C ==> therefore the IXXXX(TT) arrays contain the offsets of nonvanishing
C totally symmetric integrals.
C
      NVVVOTMX = 1
      DO IREP = 1, NREP
         IOO    (IREP+1) = IOO    (IREP) + NO  (IREP)*NO  (IREP)
         IVO    (IREP+1) = IVO    (IREP) + NV  (IREP)*NO  (IREP)
         IVV    (IREP+1) = IVV    (IREP) + NV  (IREP)*NV  (IREP)
         IOOOOTT(IREP+1) = IOOOOTT(IREP) + NOOT(IREP)*NOOT(IREP)
         IVOOOT (IREP+1) = IVOOOT (IREP) + NVO (IREP)*NOOT(IREP)
         IVVOOTT(IREP+1) = IVVOOTT(IREP) + NVVT(IREP)*NOOT(IREP)
         IVOVO  (IREP+1) = IVOVO  (IREP) + NVO (IREP)*NVO (IREP)
         IVOVVT (IREP+1) = IVOVVT (IREP) + NVO (IREP)*NVVT(IREP)
         IVVVVTT(IREP+1) = IVVVVTT(IREP) + NVVT(IREP)*NVVT(IREP)
         IVVOO  (IREP+1) = IVVOO  (IREP) + NVV (IREP)*NOO (IREP)
         IVVOOT (IREP+1) = IVVOOT (IREP) + NVV (IREP)*NOOT(IREP)
         IF (NVVT(IREP)*NVO(IREP).GT.NVVVOTMX) 
     &         NVVVOTMX=NVVT(IREP)*NVO(IREP)
      ENDDO
C
      NV1 = IOOOOTT(NREP+1)
      NV2 = IVOOOT (NREP+1)
      NV3 = IVVOOTT(NREP+1)
      NV4 = IVOVO  (NREP+1)
      NV5 = IVOVVT (NREP+1)
      NV6 = IVVVVTT(NREP+1)
C
      JVOXX(1) = 0
      JOOOO(1) = 0
      JVOOO(1) = 0
      JVVOO(1) = 0
      JVOVO(1) = 0
      JVVVO(1) = 0
      J2VOVO(1) = 0
      DO IREP = 1, NREP
         JVOXX(IREP+1) = JVOXX(IREP) + MVO(IREP)
         JOOOO(IREP+1) = JOOOO(IREP) + MOO(IREP)*MOO(IREP)
         JVOOO(IREP+1) = JVOOO(IREP) + MVO(IREP)*MOO(IREP)
         JVVOO(IREP+1) = JVVOO(IREP) + MVV(IREP)*MOO(IREP)
         JVOVO(IREP+1) = JVOVO(IREP) + MVO(IREP)*MVO(IREP)
         JVVVO(IREP+1) = JVVVO(IREP) + MVV(IREP)*MVO(IREP)
         JREP = MULTB(IREP+NREP,1+NREP,2)
         J2VOVO(IREP+1) = J2VOVO(IREP) + MVO(IREP)*MVO(JREP)
      ENDDO
      NDIMX = JVOXX(NREP+1)
C
      KVOOV (1) = 0
      KVOOO (1) = 0
      KOOOOT(1) = 0
      KVVOOT(1) = 0
      KOOVOT(1) = 0
      KOOOVT(1) = 0
      KOOVVT(1) = 0
      KVVVOT(1) = 0
      DO IREP = 1, NREP
         KVOOV  (IREP+1) = KVOOV  (IREP) + NVOO (IREP)*NV(IREP)
         KVOOO  (IREP+1) = KVOOO  (IREP) + NVOO (IREP)*NO(IREP)
         KOOOOT (IREP+1) = KOOOOT (IREP) + NOOOT(IREP)*NO(IREP)
         KVVOOT (IREP+1) = KVVOOT (IREP) + NVVOT(IREP)*NO(IREP)
         KOOVOT (IREP+1) = KOOVOT (IREP) + NOOVT(IREP)*NO(IREP)
         KOOOVT (IREP+1) = KOOOVT (IREP) + NOOOT(IREP)*NV(IREP)
         KOOVVT (IREP+1) = KOOVVT (IREP) + NVOOT(IREP)*NV(IREP)
         KVVVOT (IREP+1) = KVVVOT (IREP) + NVVVT(IREP)*NO(IREP)
      ENDDO
C
      LOOVO (1) = 0
      LVOVO (1) = 0
      LOOOOT(1) = 0
      LVVOOT(1) = 0
      LOVOOT(1) = 0
      LVOOOT(1) = 0
      LOVVOT(1) = 0
      DO IREP = 1, NREP
         LOOVO  (IREP+1) = LOOVO  (IREP) + NO(IREP)*NOVO (IREP)
         LVOVO  (IREP+1) = LVOVO  (IREP) + NV(IREP)*NOVO (IREP)
         LOOOOT (IREP+1) = LOOOOT (IREP) + NO(IREP)*NOOOT(IREP)
         LVVOOT (IREP+1) = LVVOOT (IREP) + NV(IREP)*NVOOT(IREP)
         LOVOOT (IREP+1) = LOVOOT (IREP) + NO(IREP)*NVOOT(IREP)
         LVOOOT (IREP+1) = LVOOOT (IREP) + NV(IREP)*NOOOT(IREP)
         LOVVOT (IREP+1) = LOVVOT (IREP) + NO(IREP)*NVVOT(IREP)
      ENDDO
C
C     3-index arrays are used in t3corr : make index arrays
C
      DO IJKREP = 1, NREP
       IVVVT(1,IJKREP) = 0
       DO JKREP = 1, NREP
        IREP = MULTB(JKREP+NREP,IJKREP,2)
        IVVVT(JKREP+1,IJKREP)=IVVVT(JKREP,IJKREP)+NV(IREP)*NVVT(JKREP)
       ENDDO
       JVVVT(1,IJKREP) = 0
       DO KREP = 1, NREP
        IJREP = MULTB(KREP,IJKREP,2)
        JVVVT(KREP+1,IJKREP)=JVVVT(KREP,IJKREP)+NVVT(IJREP)*NV(KREP)
       ENDDO
      ENDDO
      IVVVTMX = 1
      DO IJKREP = 1, NREP
      IF (IVVVT(NREP+1,IJKREP).GT.IVVVTMX) IVVVTMX=IVVVT(NREP+1,IJKREP)
      ENDDO

C ** here all symm arrays are set up and we can call the 
C ** parallel distribution list generator

      CALL DISLIST

C ** set up the remaining arrays for the parallel triples

      DO IREP=1,NREP
        NT3VVT(IREP)=IDIST(2,2,IREP)-IDIST(1,2,IREP)
      ENDDO

      DO IJREP = 1,NREP
        DO KREP = 1,NREP
          IJKREP = MULTB(KREP,IJREP+NREP,2)
          LLT3VVVT(KREP,IJREP)=NT3VVVT(IJKREP)
          NT3VVVT(IJKREP)=NT3VVVT(IJKREP) + NT3VVT(IJREP) * NV(KREP)
        ENDDO
      ENDDO
C
      KT3VVVOT(1)=0
      DO IREP=1,NREP
        KT3VVVOT(IREP+1) = KT3VVVOT(IREP) + NT3VVVT(IREP)*NO(IREP)
      ENDDO
C
C----------------------------------------------
C----- F O C K   S P A C E   A R R A Y S ------
C----------------------------------------------
C
C     Make the dimension and pointer arrays need in Fock space calcns.
C     Like in the CCSD(T) calculations we calculate only the arrays
C     needed in the actual sorting steps.
C
      IF (FOCKSP) THEN
C
         DO IREP = 1, NREP
            NIVIO(IREP) = 0
            NAVAO(IREP) = 0
            NAVSO (IREP) = 0
            NSOAV (IREP) = 0
            NAOSV (IREP) = 0
            NIOIOT(IREP) = 0
            NAOAOT(IREP) = 0
            NAVAVT(IREP) = 0
            NIVIVT(IREP) = 0
            NSVSVT(IREP) = 0
            NSOSOT(IREP) = 0
            NIVIVIOT(IREP) = 0
            NIOIOIVT(IREP) = 0
            NSVSVSOT(IREP) = 0
            NSVSVAVT(IREP) = 0
            NSVSOSOT(IREP) = 0
         ENDDO
C
         DO JREP = 1, NREP
            DO IREP = 1, NREP
               IJREP = MULTB(IREP,JREP,1)
               IISOAV(IREP,JREP)=NSOAV(IJREP)
               NIVIO(IJREP) = NIVIO(IJREP) + NIV(IREP)*NIO(JREP)
               NAVAO(IJREP) = NAVAO(IJREP) + NAV(IREP)*NAO(JREP)
               NAVSO(IJREP) = NAVSO(IJREP) + NAV(IREP)*NSO(JREP)
               NSOAV(IJREP) = NSOAV(IJREP) + NSO(IREP)*NAV(JREP)
               NAOSV(IJREP) = NAOSV(IJREP) + NAO(IREP)*NSV(JREP)
            ENDDO
         ENDDO
C
         DO JREP = 1, NREP
            IJREP = MULTB(JREP,JREP,1)
            NIOIOT(IJREP) = NIOIOT(IJREP) + NIO(JREP)*(NIO(JREP)-1)/2
            NAOAOT(IJREP) = NAOAOT(IJREP) + NAO(JREP)*(NAO(JREP)-1)/2
            NAVAVT(IJREP) = NAVAVT(IJREP) + NAV(JREP)*(NAV(JREP)-1)/2
            NIVIVT(IJREP) = NIVIVT(IJREP) + NIV(JREP)*(NIV(JREP)-1)/2
            NSVSVT(IJREP) = NSVSVT(IJREP) + NSV(JREP)*(NSV(JREP)-1)/2
            NSOSOT(IJREP) = NSOSOT(IJREP) + NSO(JREP)*(NSO(JREP)-1)/2
            DO IREP = JREP + 1, NREP
               IJREP = MULTB(IREP,JREP,1)
               NIOIOT(IJREP) = NIOIOT(IJREP) + NIO(IREP)*NIO(JREP)
               NAOAOT(IJREP) = NAOAOT(IJREP) + NAO(IREP)*NAO(JREP)
               NAVAVT(IJREP) = NAVAVT(IJREP) + NAV(IREP)*NAV(JREP)
               NIVIVT(IJREP) = NIVIVT(IJREP) + NIV(IREP)*NIV(JREP)
               NSVSVT(IJREP) = NSVSVT(IJREP) + NSV(IREP)*NSV(JREP)
               NSOSOT(IJREP) = NSOSOT(IJREP) + NSO(IREP)*NSO(JREP)
            ENDDO
         ENDDO
C
         DO KREP = 1, NREP
          DO IJREP = 1, NREP
           IJKREP = MULTB(KREP,IJREP+NREP,2)
           KKIVIVIOT(IJREP,KREP) = NIVIVIOT(IJKREP)
           KKIOIOIVT(IJREP,KREP) = NIOIOIVT(IJKREP)
           KKSVSVAVT(IJREP,KREP) = NSVSVAVT(IJKREP)
           KKSVSVSOT(IJREP,KREP) = NSVSVSOT(IJKREP)
           NIVIVIOT(IJKREP) = NIVIVIOT(IJKREP) + NIVIVT(IJREP)*NIO(KREP)
           NIOIOIVT(IJKREP) = NIOIOIVT(IJKREP) + NIOIOT(IJREP)*NIV(KREP)
           NSVSVAVT(IJKREP) = NSVSVAVT(IJKREP) + NSVSVT(IJREP)*NAV(KREP)
           NSVSVSOT(IJKREP) = NSVSVSOT(IJKREP) + NSVSVT(IJREP)*NSO(KREP)
          ENDDO
         ENDDO
C
         DO IJREP = 1, NREP
          DO KREP = 1, NREP
           IJKREP = MULTB(KREP,IJREP+NREP,2)
           LLSVSOSOT(KREP,IJREP) = NSVSOSOT(IJKREP)
           NSVSOSOT(IJKREP) = NSVSOSOT(IJKREP)+NSOSOT(IJREP)*NSV(KREP)
          ENDDO
         ENDDO
C
         IAVSO(1) = 0
         IAVAV(1) = 0
         IAOAO(1) = 0
         KIVIVIOAVT(1) = 0
         KIOIOIVAOT(1) = 0
         KSVSVSOAVT(1) = 0
         KSVSVAVAVT(1) = 0
         DO IREP = 1, NREP
          IAVSO(IREP+1) = IAVSO(IREP) + NAV(IREP) * NSO(IREP)
          IAVAV(IREP+1) = IAVAV(IREP) + NAV(IREP) * NAV(IREP)
          IAOAO(IREP+1) = IAOAO(IREP) + NAO(IREP) * NAO(IREP)
          KIVIVIOAVT(IREP+1) = KIVIVIOAVT(IREP)+NIVIVIOT(IREP)*NAV(IREP)
          KIOIOIVAOT(IREP+1) = KIOIOIVAOT(IREP)+NIOIOIVT(IREP)*NAO(IREP)
          KSVSVSOAVT(IREP+1) = KSVSVSOAVT(IREP)+NSVSVSOT(IREP)*NAV(IREP)
          KSVSVAVAVT(IREP+1) = KSVSVAVAVT(IREP)+NSVSVAVT(IREP)*NAV(IREP)
         ENDDO
C
         LAOSVSOSOT(1) = 0
         DO IREP = 1, NREP
          LAOSVSOSOT(IREP+1) = LAOSVSOSOT(IREP)+NAO(IREP)*NSVSOSOT(IREP)
         ENDDO
C
      ENDIF
C
C     Reorder the spinor eigenvalues
C
      DO ISP = 1, NSP
         IREP = IREPSP(ISP,2)
         II = IREPSP(ISP,3)
         IF (II.GT.0) THEN
            I = IO(IREP) + II
         ELSE
            I = IO(NREP+1) + IV(IREP) - II
         ENDIF
         EPS(I) = EPS1(ISP)
      ENDDO
C
      IF (FOCKSP) THEN
         DO ISP = 1, NSP
            IREP = IREPSP(ISP,2)
            II = IREPSP(ISP,4)
            IF (II.GT.0) THEN
               I = IO(IREP) + II
            ELSE
               I = IO(NREP+1) + IV(IREP) - II
            ENDIF
            EPS(I) = EPS1(ISP)
         ENDDO
      ENDIF
C
 1000 FORMAT (/' Configuration in highest pointgroup'//T40,16(1X,A4))
 1001 FORMAT (//' Configuration in abelian subgroup'//T40,8(1X,A4))
 1002 FORMAT (' Spinor class : ',A,T40,16(1X,I4))
 1003 FORMAT (//' List of frozen spinors (amplitudes zeroed out)')
 1004 FORMAT (//' List of inactive and active spinors (Fock space)')
      RETURN 
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCSETI (ICALC,CC,KFREE,LFREE,MXCORR,MREMAIN,EPS,
     &                   NSP,IREPSP,IREPSPI)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Driver to generate the sorted integral files
C
C     Menu driven routine. Depending on value of ICALC
C
C       1) Calculate memory requirements for the different modules
C       2) Produce desired integral files or rebuild Fock matrix
C          - OOOO, VOOO, VVOO and VOVO files
C          - VOVV file
C          - VVVV file
C          - Fock matrix
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
      REAL*8 CC(*)
      REAL*8 EPS(*)
      INTEGER IREPSP(NSP,4),IREPSPI(NSP,16,2)
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "iobuf.inc"
      INCLUDE "diis.inc"
      INCLUDE "inpt.inc"
      INCLUDE "symm.inc"
      INCLUDE "eqns.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
C
C---------------Local variables--------------------------------------
C
      LOGICAL ALLOC,SRTALL
C
C---------------Executable code--------------------------------------
C
      ALLOC = ICALC.GE.2
C
C  Allocate core for integral sorting step
C
      KFRSAV = KFREE
      LFRSAV = LFREE
      CALL MEMOPT('INTE',KR,2*NSP+2,CC,KFREE,LFREE,ALLOC)
      IF (EQNS.EQ.'FOCKSP') THEN
         CALL MEMOPT('INTE',INDEX,NSP*NSP*16,CC,KFREE,LFREE,ALLOC)
      ELSE
         CALL MEMOPT('INTE',INDEX,NSP*NSP*4,CC,KFREE,LFREE,ALLOC)
      ENDIF
      CALL MEMOPT('INTE',INDK,NSP*NSP,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('INTE',INDL,NSP*NSP,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',CBUF,NSP*NSP*RCW,CC,KFREE,LFREE,ALLOC)
      IF (EQNS.EQ.'FOCKSP') THEN
         CALL MEMOPT('INTE',IBUF,NSP*NSP*7*256,CC,KFREE,LFREE,ALLOC)
      ELSE
         CALL MEMOPT('INTE',IBUF,NSP*NSP*7*16,CC,KFREE,LFREE,ALLOC)
      ENDIF
      CALL MEMOPT('REAL',BUF1,NSP*NSP,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BUF2,NSP*NSP,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FVO,NFVO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',V1 ,NV1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',V1A,NV1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',V2 ,NV2*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',V2A,NV2*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',V3 ,NV3*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',V3A,NV3*RCW,CC,KFREE,LFREE,ALLOC)
      MXCORR = MAX0(MXCORR,KFREE)
C
C     After sorting and antisymmetrizing the OOOO,VOOO and VVOO integrals
C     parts of the above arrays are not needed anymore and could be used
C     for buffering the VOVV and VVVV integrals as well. but this is not
C     a critical shortage of memory so far.
C
C     The maximum necessary size is
C
      NVT = MAX0(NV5,NV6)
      NVT = MAX0(NVT,NV4)
      NVT = MAX0(NVT,JOOOO(2))
      NVT = MAX0(NVT,JVOOO(2))
C
C     The remaining space is
C
      NVF = (LFREE-4) / (2 * RCW )
C
C  Determine number of available buffers with respect to free memory
C  -----------------------------------------------------------------
C
      IF (NVT.LT.NVF) THEN
         NBUF = NVT / MINBUF + 1
      ELSE
         NBUF = NVF / MINBUF
      ENDIF
      IF (NBUF.LT.1) NBUF = 1
      NVT = NBUF * MINBUF
C
C     We must be able to store at least a NV4 size array, check that.
C     Since we use this array as work in MAKEFM we also need to store the
C     first representation of the sorted (non-triangular) OOOO and VOOO ints
C
      NVTMIN = MAX0(NVT,NV4)
      NVTMIN = MAX0(NVTMIN,JOOOO(2))
      NVTMIN = MAX0(NVTMIN,JVOOO(2))
C
      CALL MEMOPT('REAL',VT ,NVTMIN*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',VTA,NVTMIN*RCW,CC,KFREE,LFREE,ALLOC)
      V4  = VT
      V4A = VTA
      MXCORR = MAX0(MXCORR,KFREE)
C
      IF (ICALC.EQ.1) THEN
         if (myproc.eq.master)
     &   WRITE (IW,1001) "reading and sorting integrals",MXCORR
         KFREE = KFRSAV
         LFREE = LFRSAV
         RETURN
      ENDIF
C
C  Read integrals & make fock matrices
C
      SRTALL = .TRUE.
      IF (EQNS.NE.'FOCKSP') SRTALL = DOCCSD
C
      CALL RDINTS(IPRNT,NSP,CC(INDEX),CC(KR),CC(INDK),CC(INDL),
     &            CC(CBUF),CC(IBUF),NVT,CC(BUF1),CC(BUF2),IREPSP,
     &            IREPSPI,CC(V1),CC(V1A),
     &            CC(V2),CC(V2A),CC(V3),CC(V3A),CC(V4),CC(V4A),
     &            CC(VT),CC(VTA),CC(VT),CC(VTA),EPS,CC(FOO),CC(FVO),
     &            CC(FVV),BREIT,SRTALL,INTERFACE,MREMAIN,cc)
C
      CALL MEMREL('CCSETI',CC,1,KFRSAV,KFREE,LFREE)
C
      RETURN
1001  FORMAT (" Core used for ",A," :",T50,I10," 8-byte words")
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCENER (ICALC,CC,KFREE,LFREE,MXCORR,EPS)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Driver for energy calculations
C
C     Menu driven routine. Depending on value of ICALC
C
C       1) Calculate memory requirements for the different modules
C       2) Calculate energy and wave function at the
C          - SCF level
C          - MP2 level
C          - CCSD level
C          - CCSD(T) level
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "iobuf.inc"
      INCLUDE "diis.inc"
      INCLUDE "inpt.inc"
      INCLUDE "symm.inc"
      INCLUDE "eqns.inc"
      INCLUDE "results.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
C
C---------------Local variables--------------------------------------
C
      REAL*8 CC(*)
      REAL*8 EPS(*)
      REAL*8 TOL
      LOGICAL ALLOC
C
C---------------Executable code--------------------------------------
C
      ALLOC = ICALC.GE.2
      IF (ICALC.LE.0) RETURN
C
C Allocate space for the calculation of the amplitudes
C
      KFRSAV = KFREE
      LFRSAV = LFREE
      CALL MEMOPT('REAL',FVO,NFVO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',T1,NDIMT1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',T2,NDIMT2*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',S1,NDIMT1*RCW,CC,KFREE,LFREE,ALLOC)
      KFRSAV1 = KFREE
      CALL MEMOPT('REAL',S2,NDIMT2*RCW,CC,KFREE,LFREE,ALLOC)
C
C This is all we need to calculate the MP2 energy
C
      IF (DOMP2) MXCORR = KFREE
C
      CALL MEMOPT('REAL',AZ,NV1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',H ,NV4*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',HO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',HV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',HOV,NFVO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',GOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',GVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      MAXDIM = MXDIMCC
      CALL MEMOPT('REAL',CCC,MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB1,(MAXDIM+1)*(MAXDIM+2),CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB2,(MAXDIM+1)*(MAXDIM+2),CC,KFREE,LFREE,ALLOC)
      NBUF1 = MAX0(JOOOO(NREP+1),JVOOO(NREP+1),
     &             JVVOO(NREP+1),JVOVO(NREP+1))
      NBUF2 = NBUF1
      CALL MEMOPT('REAL',BUF1,NBUF1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BUF2,NBUF2*RCW,CC,KFREE,LFREE,ALLOC)
C
C     Calculate size of the 3rd work array
C     The last array is used to buffer in the <VV||VV> and <VO||VV>
C     integrals, start by making it as large as possible.
C
      NBUF3 = (LFREE - 4) / RCW
C
C     Calculate maximum size necessary for the VOVV and VVVV buffers
C
      NV5IRP = 1
      NV6IRP = 1
      DO IRP = 1, NREP
         NV5IRP = MAX0(NV5IRP,NVO (IRP)*NVVT(IRP))
         NV6IRP = MAX0(NV6IRP,NVVT(IRP)*NVVT(IRP))
      ENDDO
C
      NVIRP = MAX0(NV5IRP,NV6IRP)
      NBUF3 = MIN0(NVIRP,NBUF3)
C
C     Check the minimum size for the general use of this array
C
      NBUF3 = MAX0(NBUF1,NBUF3)
C
C     Allocate the work array
C
      CALL MEMOPT('REAL',BUF3,NBUF3*RCW,CC,KFREE,LFREE,ALLOC)
C        
      IF (ICALC.EQ.1.and.(myproc.eq.master)) 
     &   WRITE (IW,1001) "calculating amplitudes",KFREE
C
      IF (DOCCSD) THEN
         MXCORR = MAX0(MXCORR,KFREE)
      ENDIF
C
C  Calculate requirements for triples correction.
C  Use MEMOPT later.
C
      TOP = S1
      VOOO  = TOP
      T2S   = VOOO + NV2*RCW + RCW
      T2T   = T2S + IVVOOT(NREP+1)*RCW + RCW
      VVOO  = T2T + LOVVOT(NREP+1)*RCW + RCW
      VVVO  = VVOO + NDIMT2*RCW + RCW
      BUF1B = VVVO + KVVVOT(NREP+1)*RCW + RCW
      BUF2B = BUF1B + IVVVTMX*RCW + RCW
      BUF3B = BUF2B + IVVVTMX*RCW + RCW
      BUF4B = BUF3B + IVVVTMX*RCW + RCW
      TOP = BUF4B + MAX0(NVVVOTMX,NDIMT2)*RCW + RCW
      IF(ICALC.EQ.1.and.(myproc.eq.master)) 
     &   WRITE (IW,1001) "in core evaluation of triples",TOP
      IF (DOCCSDT) MXCORR = MAX0(MXCORR,TOP)
C
      IF (ICALC.EQ.1) THEN
         KFREE = KFRSAV
         LFREE = LFRSAV
         RETURN
      ENDIF
C
      if (myproc.eq.master) WRITE (IW,1007) DOMP2,DOCCSD,DOCCSDT
      EQNS = 'AMPLTD'
C
C     Read the Fock matrix from file
C
      CALL FMTOFILE (.FALSE.,CC(FVO),CC(FOO),CC(FVV))
C
C  Solve relativistic MP2 equations
C
      IF (DOMP2) THEN
         IF (IMSTAT(4).EQ.3) THEN
            if (myproc.eq.master) WRITE (IW,1010)
            GOTO 10
         ENDIF
C
         CALL MP2EQN(EPS,CC(FVO),CC(T1),CC(S1),CC(T2),CC(S2))
C
C        This is a restart point: save the amplitudes and update status.
C
         CALL PUTAMPT(CC(T1),CC(T2))
         IMSTAT(4) = 3
         CALL CCDUMP
   10    CONTINUE
      ENDIF
C
C  Solve relativistic CCSD equations
C
   11 IF (DOCCSD) THEN
         IF (IMSTAT(5).EQ.3) THEN
            if (myproc.eq.master) WRITE (IW,1011)
            GOTO 20
         ENDIF
         if (myproc.eq.master)
     &       WRITE (IW,1008) MXITCC,MXDIMCC,10.0D0**(-NTOLCC)
         MAXDIM = MXDIMCC
         MAXIT  = MXITCC
         TOL = 10.0D0**(-NTOLCC)
C
C        Initialize T1 and T2 amplitudes
C
         IF (IMSTAT(5).EQ.2) THEN
C
C           Use restart amplitudes
C
            CALL GETAMPT (CC(T1),CC(T2))
C
         ELSEIF (IMSTAT(4).EQ.3) THEN
C
C           Use MP2 amplitudes
C
            CALL GETAMPT (CC(T1),CC(T2))
C
         ELSE   
C
C           Use standard initialization
C
            CALL XCOPY (NDIMT1,CC(FVO),1,CC(T1),1)
            CALL GETVVOO (CC(T2))
            CALL DENOM (EPS,CC(T1),CC(T2),CC(T1),CC(T2))
            CALL ZCORE (CC(T1),CC(T2))
C
         ENDIF
C
         CALL PUTAMPT(CC(T1),CC(T2))
         IMSTAT(5) = 2
         CALL CCDUMP
C
         CALL XTIME(2,1,'CCSD equations                ')
         CALL CCEQN(EPS,CC(FOO),CC(FVO),CC(FVV),CC(T1),CC(S1),
     &           CC(T2),CC(S2),CC(AZ),DUM,CC(H),CC(HO),CC(HV),CC(HOV),
     &           CC(GOO),CC(GVV),CC(BUF1),CC(BUF2),CC(BUF3),
     &           CC(CCC),CC(BB1),CC(BB2),
     &           TOL,NBUF2,NBUF3)
         CALL XTIME(2,2,'CCSD equations                ')
C
C        This is a restart point: save the amplitudes and update status.
C
         CALL PUTAMPT(CC(S1),CC(S2))
         IMSTAT(5) = 3
         CALL CCDUMP
   20    CONTINUE
      ENDIF
C
C  Calculate T3 corrections
C
C
      IF (DOCCSDT) THEN
         IF (IMSTAT(6).EQ.3) THEN
            if (myproc.eq.master) WRITE (IW,1012)
            GOTO 30
         ENDIF
         CALL MEMREL('CCENER',CC,1,KFRSAV1,KFREE,LFREE)
         CALL MEMOPT('REAL',VOOO,NV2*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',T2S,IVVOOT(NREP+1)*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',T2T,LOVVOT(NREP+1)*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',VVOO,NDIMT2*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',VVVO,KVVVOT(NREP+1)*RCW,
     &               CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',BUF1,IVVVTMX*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',BUF2,IVVVTMX*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',BUF3,IVVVTMX*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',BUF4,MAX0(NVVVOTMX,NDIMT2)*RCW,
     &               CC,KFREE,LFREE,ALLOC)
C
C        Check if CCSD amplitudes are available
C
         IF (IMSTAT(5).EQ.3) THEN
            CALL GETAMPT (CC(T1),CC(T2))
         ELSEIF (IMSTAT(4).EQ.3) THEN
            if (myproc.eq.master) WRITE (IW,1006)
            CALL GETAMPT (CC(T1),CC(T2))
         ELSE
            DOCCSD = .TRUE.
            GOTO 11
         ENDIF
C
         CALL T3CORR (CC(FVO),EPS,CC(T1),CC(T2),CC(T2S),CC(T2T),
     &                CC(BUF1),CC(BUF2),CC(BUF3),CC(BUF4),
     &                CC(VVVO),CC(VVOO),CC(VOOO))
C
C     This is a restart point : update status.
C
         IMSTAT(6) = 3
         CALL CCDUMP
   30    CONTINUE
      ENDIF
C
      CALL MEMREL('CCENER',CC,1,KFRSAV,KFREE,LFREE)
C
      RETURN
1001  FORMAT (" Core used for ",A," :",T50,I10," 8-byte words")
1007  FORMAT (//" Energy calculations"
     &        /" MP2 module active :",T44,L1
     &        /" CCSD module active :",T44,L1
     &        /" CCSD(T) module active :",T44,L1)
1008  FORMAT (//" CCSD options :"
     &        /" Maximum number of iterations :",T40,I5
     &        /" Maximum size of DIIS space :",T40,I5
     &        /" Convergence criterium :",T38,E7.1)
1006  FORMAT (/' WARNING : Calculating CCSD(T) energies with MP2',
     &         ' amplitudes')
1010  FORMAT (/' Skipping MP2 calculation')
1011  FORMAT (/' Skipping CCSD calculation')
1012  FORMAT (/' Skipping CCSD(T) calculation')
C015  FORMAT (//" ********************************************"
C    &         /" ** Parallel Triples not implemented yet ! **"
C    &         /" ********************************************")
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCFOPR (ICALC,NSP,IREPSPI,CC,KFREE,LFREE,MXCORR,
     &                   EPS)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Driver for gradient calculations
C
C     Menu driven routine. Depending on value of ICALC
C
C       1) Calculate memory requirements for the different modules
C       2) Calculate first order properties at the
C          - SCF level
C          - MP2 level
C          - CCSD level
C          - CCSD(T) level
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
      DIMENSION IREPSPI(*)
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "param.inc"
      INCLUDE "files.inc"
      INCLUDE "iobuf.inc"
      INCLUDE "diis.inc"
      INCLUDE "inpt.inc"
      INCLUDE "eqns.inc"
      INCLUDE "results.inc"
      INCLUDE "symm.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
#if defined (VAR_MPI)
      INCLUDE 'mpif.h'
      DIMENSION ISTAT(MPI_STATUS_SIZE)
#endif
C
C---------------Local variables--------------------------------------
C
      REAL*8 CC(*)
      REAL*8 EPS(*)
      REAL*8 TOL
      COMPLEX*16 EPHASE,CEXPA
      LOGICAL ALLOC
C
C---------------Executable code--------------------------------------
C
      if (doccsdg) then
         if (myproc.eq.master)
     &         WRITE (IW,*) ' CCSD gradient not yet implemented,'
     &         ,' calculate MP2 gradient instead'
         doccsdg = .false.
         domp2g = .true.
      endif
#if defined (VAR_MPI)
      IF (NMPROC.GT.1.AND.DOMP2G) THEN
         if (myproc.eq.master)
     &   WRITE (IW,*) ' parallel MP2 gradient not yet implemented,'
     &         ,' calculate HF gradient'
         domp2g = .false.
      ENDIF
#endif
      ALLOC = ICALC.GE.2
      IF (ICALC.LE.0) RETURN
C
C The DIIS algorithm is used for the Z-vector and Lamda-equations
C Allocate the workarrays only once with the maximum dimensions
C
      MAXIT  = MXITGR
      MAXDIM = MXDIMGR
      IF (DOCCSDG) MAXIT = MAX0(MAXIT,MXITCC)
      IF (DOCCSDG) MAXDIM = MAX0(MAXDIM,MXDIMCC)
C
C Allocate space for the calculation of the gradient
C
      KFRSAV = KFREE
      LFRSAV = LFREE
      CALL MEMOPT('REAL',FOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FVO,NFVO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',T1,NDIMT1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',T2,NDIMT2*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',S1,NDIMT1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',S2,NDIMT2*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',DOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',DVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',XOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',XVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',DVO,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',DOV,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',D2VO,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',D2OV,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',XVO,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',XOV,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',EVO,NEOPER*NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',EOV,NEOPER*NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',EOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',EVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',DG ,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      NBUF1 = MAX0(JOOOO(NREP+1),JVOOO(NREP+1),
     &             JVVOO(NREP+1),JVOVO(NREP+1))
      NBUF2 = NBUF1
      CALL MEMOPT('REAL',CCC,MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB1,(MAXDIM+1)*(MAXDIM+2),CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB2,(MAXDIM+1)*(MAXDIM+2),CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BUF1,NBUF1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',CBUF,2*NSP*NSP,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BUF2,NBUF2*RCW,CC,KFREE,LFREE,ALLOC)
C
C     Calculate size of the 3rd work array
C     The last array is used to buffer in the <VV||VV> and <VO||VV>
C     integrals, start by making it as large as possible.
C
      NBUF3 = (LFREE - 4) / RCW
C
C     Calculate maximum size necessary for the VOVV and VVVV buffers
C
      NV5IRP = 1
      NV6IRP = 1
      DO IRP = 1, NREP
         NV5IRP = MAX0(NV5IRP,NVO (IRP)*NVVT(IRP))
         NV6IRP = MAX0(NV6IRP,NVVT(IRP)*NVVT(IRP))
      ENDDO
C
      NVIRP = MAX0(NV5IRP,NV6IRP)
      NBUF3 = MIN0(NVIRP,NBUF3)
C
C     Check the minimum size for the general use of this array
C
      NBUF3 = MAX0(NBUF1,NBUF3)
C
C     Allocate the work array
C
      CALL MEMOPT('REAL',BUF3,NBUF3*RCW,CC,KFREE,LFREE,ALLOC)
C
      IF (DOCCSDG) THEN
         CALL MEMOPT('REAL',AZ,NV1*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',H ,NV4*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',HO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',HV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',HOV,NFVO*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',GOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',GVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
         CALL MEMOPT('REAL',CZ,NV2*RCW,CC,KFREE,LFREE,ALLOC)
      ENDIF
C
      IF (DOCCSDG) MXCORR = KFREE
C
      IF (ICALC.EQ.1) THEN
         if (myproc.eq.master) 
     &      WRITE (IW,1001) "Gradient calculation",KFREE
         KFREE = KFRSAV
         LFREE = LFRSAV
         RETURN
      ENDIF
C
      if (myproc.eq.master) 
     &WRITE (IW,1007) DOMP2G,DOCCSDG,DOCCSDTG,
     &                MXITGR,MXDIMGR,10.0D0**(-NTOLGR)
      EQNS = 'LAMBDA'
C
C     Read the Fock matrix from file
C
      CALL FMTOFILE (.FALSE.,CC(FVO),CC(FOO),CC(FVV))
C
C     Start with SCF (reference determinant) expectation values
C
      if (myproc.eq.master) WRITE (IW,1002) '    SCF'
      CALL XCOPY (NFOO,A0,0,CC(DOO),1)
      CALL XCOPY (NFVV,A0,0,CC(DVV),1)
      CALL XCOPY (NDIMX,A0,0,CC(DVO),1)
      CALL XCOPY (NDIMX,A0,0,CC(DOV),1)
C
      DO EOPER = 1, NEOPER
         EOFF = (EOPER-1)*NDIMX*RCW+1
         CALL RDPROP(IPRNT,NAMEE(EOPER),NSP,LTR,CC(CBUF),IREPSPI,
     &               EPHASE,CC(EVO),CC(EOV),CC(EOO),CC(EVV))
         CALL EXPVAL(CC(DOO),CC(DVV),CC(DVO),CC(DOV),
     &               CC(EOO),CC(EVV),CC(EVO),CC(EOV),
     &               EPHASE,CEXPA)
         if (myproc.eq.master) WRITE (IW,1004) NAMEE(EOPER),CEXPA
      ENDDO
C
C     Get MP2 relaxed density matrix
C
      IF (DOMP2G) THEN
C
C        Solve relativistic MP2 lambda equations
C
         CALL MP2EQN(EPS,CC(FVO),CC(T1),CC(S1),CC(T2),CC(S2))
C
C        Get amplitude part of density matrix
C
         CALL CCDENSC (1,CC(T1),CC(S1),CC(T2),CC(S2),
     &                 CC(BUF1),CC(BUF2),CC(BUF3),CC(DOO),CC(DVV),
     &                 CC(DVO),CC(DOV))
C
C        Solve Z-vector equations
C
         TOL = 10.0D0**(-NTOLGR)
         MAXIT  = MXITGR
         MAXDIM = MXDIMGR
         CALL CCDENSZ (1,NSP,IREPSPI,EPS,CC(T1),CC(S1),CC(T2),CC(S2),
     &                 CC(BUF1),CC(BUF2),CC(BUF3),NBUF2,NBUF3,CC(CBUF),
     &                 CC(XVO),CC(XOV),CC(DOO),CC(DVV),CC(DVO),CC(DOV),
     &                 CC(EVO),CC(EOV),CC(D2VO),CC(D2OV),CC(DG),
     &                 CC(CCC),CC(BB1),CC(BB2),TOL)
C
         if (myproc.eq.master) WRITE (IW,1002) '    MP2'
         DO EOPER = 1, NEOPER
            EOFF = (EOPER-1)*NDIMX*RCW+1
            CALL RDPROP(IPRNT,NAMEE(EOPER),NSP,LTR,CC(CBUF),IREPSPI,
     &                  EPHASE,CC(EVO),CC(EOV),CC(EOO),CC(EVV))
            CALL EXPVAL(CC(DOO),CC(DVV),CC(DVO),CC(DOV),
     &                  CC(EOO),CC(EVV),CC(EVO),CC(EOV),
     &                  EPHASE,CEXPA)
            if (myproc.eq.master) WRITE (IW,1004) NAMEE(EOPER),CEXPA
         ENDDO
C
      ENDIF
C
C     Get CCSD relaxed density matrix
C
      IF (DOCCSDG) THEN
C
C        Solve relativistic CCSD lambda equations
C
C        The CCSD energy calculation should be completed
C
         IF (IMSTAT(5).NE.3) THEN
            if (myproc.eq.master) WRITE (IW,1009) 
            RETURN
         ENDIF
C
C        No restart: start by copying T1 and T2 amplitdues to L1 and L2
C
         CALL GETAMPT (CC(T1),CC(T2))
C
         if (myproc.eq.master)
     &      WRITE (IW,1008) MXITCC,MXDIMCC,10.0D0**(-NTOLCC)
         MAXDIM = MXDIMCC
         MAXIT  = MXITCC
         TOL = 10.0D0**(-NTOLCC)
         NINTSB = 20
         CALL RFILE(ITAPL,NINTSB)
C
         CALL CCEQN(EPS,CC(FOO),CC(FVO),CC(FVV),CC(T1),CC(S1),
     &           CC(T2),CC(S2),CC(AZ),CC(CZ),CC(H),CC(HO),CC(HV),
     &           CC(HOV),CC(GOO),CC(GVV),CC(BUF1),CC(BUF2),CC(BUF3),
     &           CC(CCC),CC(BB1),CC(BB2),
     &           TOL,NBUF2,NBUF3)
C
C        Put T1 and T2 amplitudes back in place
C        L1 and L2 amplitudes are in S1, S2
C
         CALL GETAMPT(CC(T1),CC(T2))
C
C        Get amplitude part of density matrix
C
         CALL CCDENSC (1,CC(T1),CC(S1),CC(T2),CC(S2),
     &                 CC(BUF1),CC(BUF2),CC(BUF3),CC(DOO),CC(DVV),
     &                 CC(DVO),CC(DOV))
C
C        Solve Z-vector equations
C
         TOL = 10.0D0**(-NTOLGR)
         MAXIT  = MXITGR
         MAXDIM = MXDIMGR
c        CALL CCDENSZ (1,NSP,IREPSPI,EPS,CC(T1),CC(S1),CC(T2),CC(S2),
c    &                 CC(BUF1),CC(BUF2),CC(BUF3),NBUF2,NBUF3,CC(CBUF),
c    &                 CC(XVO),CC(XOV),CC(DOO),CC(DVV),CC(DVO),CC(DOV),
c    &                 CC(EVO),CC(EOV),CC(D2VO),CC(D2OV),CC(DG),
c    &                 CC(CCC),CC(BB1),CC(BB2),TOL)
C
         if (myproc.eq.master) WRITE (IW,1002) '   CCSD'
         DO EOPER = 1, NEOPER
            EOFF = (EOPER-1)*NDIMX*RCW+1
            CALL RDPROP(IPRNT,NAMEE(EOPER),NSP,LTR,CC(CBUF),IREPSPI,
     &                  EPHASE,CC(EVO),CC(EOV),CC(EOO),CC(EVV))
            CALL EXPVAL(CC(DOO),CC(DVV),CC(DVO),CC(DOV),
     &                  CC(EOO),CC(EVV),CC(EVO),CC(EOV),
     &                  EPHASE,CEXPA)
            if (myproc.eq.master) WRITE (IW,1004) NAMEE(EOPER),CEXPA
         ENDDO
C
      ENDIF
C
      CALL MEMREL('CCFOPR',CC,1,KFRSAV,KFREE,LFREE)
C
      RETURN
1001  FORMAT (" Core used for ",A," :",T50,I10," 8-byte words")
1007  FORMAT (//" Gradient calculations"
     &        /" MP2 module active :",T44,L1
     &        /" CCSD module active :",T44,L1
     &        /" CCSD(T) module active :",T44,L1
     &        //" Z-vector equations :"
     &        /" Maximum number of iterations :",T40,I5
     &        /" Maximum size of DIIS space :",T40,I5
     &        /" Convergence criterium :",T38,E7.1)
1002  FORMAT(//,1X,A7,' Gradient results',//3X,'Expectation value',13X,
     & 'Real part',8X,'Imaginary part')
1004  FORMAT('  <',A8,'> ',T30,2F20.13)
1008  FORMAT (//" CCSD lambda-equations :"
     &        /" Maximum number of iterations :",T40,I5
     &        /" Maximum size of DIIS space :",T40,I5
     &        /" Convergence criterium :",T38,E7.1)
1009  FORMAT (/" WARNING : Cannot solve CCSD lambda equations :",
     &         " T1 and T2 amplitudes are not available "/
     &         " Check that you specified DOENER and DOCCSD !")
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCHESS (ICALC,CC,KFREE,LFREE,MXCORR,EPS,
     &                   NSP,IREPSPI)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Driver for hessian calculations
C
C     Menu driven routine. Depending on value of ICALC
C
C       1) Calculate memory requirements for the different modules
C       2) Calculate second order properties at the
C          - SCF (RPA) level
C          - MP2 level
C          - CCSD level
C          - CCSD(T) level
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
      REAL*8 CC(*)
      REAL*8 EPS(*)
      DIMENSION IREPSPI(*)
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "iobuf.inc"
      INCLUDE "diis.inc"
      INCLUDE "inpt.inc"
      INCLUDE "symm.inc"
      INCLUDE "param.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
C
C---------------Local variables--------------------------------------
C
      COMPLEX*16 APHASE(MAXOP),BPHASE
      REAL*8 TOL
      LOGICAL BDONE
      LOGICAL ALLOC
C
C---------------Executable code--------------------------------------
C
      ALLOC = ICALC.GE.2
      IF (ICALC.LE.0) RETURN
C
C Allocate space for the calculation of the hessian
C
      KFRSAV = KFREE
      LFRSAV = LFREE
      CALL MEMOPT('REAL',X1,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',X2,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',Y1,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',Y2,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',AVO,NAOPER*NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',AOV,NAOPER*NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BVO,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BOV,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',DG ,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      MAXDIM = MXDIMRP
      CALL MEMOPT('REAL',CCC,MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB1,(MAXDIM+1)*(MAXDIM+2),CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB2,(MAXDIM+1)*(MAXDIM+2),CC,KFREE,LFREE,ALLOC)
      NBUF1 = MAX0(JVVOO(NREP+1),JVOVO(NREP+1))
      CALL MEMOPT('REAL',BUF1,NBUF1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BUF2,NBUF1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',CBUF,2*NSP*NSP,CC,KFREE,LFREE,ALLOC)
      MXCORR = KFREE
C
      IF (ICALC.LE.1) THEN
         if (myproc.eq.master) WRITE (IW,1001) "RPA calculation",KFREE
         KFREE = KFRSAV
         LFREE = LFRSAV
         RETURN
      ENDIF
C
C  Solve relativistic Random Phase Approximation equations
C
      if (myproc.eq.master)
     &    WRITE (IW,1009) MXITRP,MXDIMRP,10.0D0**(-NTOLRP)
      MAXIT  = MXITRP
      TOL = 10.0D0**(-NTOLRP)
      MAXDIM = MXDIMRP
      DO AOPER = 1, NAOPER
         AOFF = (AOPER-1)*NDIMX*RCW
         CALL RDPROP(IPRNT,NAMEA(AOPER),NSP,LFA,CC(CBUF),IREPSPI,
     &               APHASE(AOPER),CC(AVO+AOFF),CC(AOV+AOFF),DUM,DUM)
      ENDDO
      DO BOPER = 1, NBOPER
         BDONE = .FALSE.
         CALL RDPROP(IPRNT,NAMEB(BOPER),NSP,LFA,CC(CBUF),IREPSPI,
     &               BPHASE,CC(BVO),CC(BOV),DUM,DUM)
         DO IFREQ = 1, NFREQ
            IF (IPRNT.GE.1.and.(myproc.eq.master)) 
     &          WRITE (IW,1010) NAMEB(BOPER),EFREQ(IFREQ)
            CALL RPAA
     &           (NAOPER,NAMEA,NAMEB(BOPER),APHASE,BPHASE,BDONE,EPS,
     &           EFREQ(IFREQ),CC(AVO),CC(AOV),CC(BVO),CC(BOV),CC(X1),
     &           CC(X2),CC(Y1),CC(Y2),CC(DG),CC(BUF1),CC(BUF2),
     &           CC(CCC),CC(BB1),CC(BB2),TOL,IPRNT,DEBUG,
     &           TIMING)
            CALL FLSHFO(IW)
         ENDDO
      ENDDO
C

      RETURN
1001  FORMAT (" Core used for ",A," :",T50,I10," 8-byte words")
1009  FORMAT (//" Propagator (RPA) module"
     &        /" Maximum number of iterations :",T40,I5
     &        /" Maximum size of DIIS space :",T40,I5
     &        /" Convergence criterium :",T38,E7.1)
1010  FORMAT (//" Random Phase Approximation : ",
     &        /" Calculate propagators of ",A8," (B)",
     &        " at frequency :",F15.5)
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCEXC (ICALC,CC,KFREE,LFREE,MXCORR,EPS,
     &                  NSP,IREPSPI)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Driver for excited state calculations
C
C     Menu driven routine. Depending on value of ICALC
C
C       1) Calculate memory requirements for the different modules
C       2) Calculate excitation energies at the
C          - SCF (RPA) level
C          - MP2 level
C          - CCSD level
C          - CCSD(T) level
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
      REAL*8 CC(*)
      REAL*8 EPS(*)
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "iobuf.inc"
      INCLUDE "diis.inc"
      INCLUDE "inpt.inc"
      INCLUDE "symm.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
C
C---------------Local variables--------------------------------------
C
      COMPLEX*16 APHASE(MAXOP),BPHASE
      REAL*8 TOL
      LOGICAL BDONE
      LOGICAL ALLOC
C
C---------------Executable code--------------------------------------
C
      ALLOC = ICALC.GE.2
      IF (ICALC.LE.0) RETURN
C
C Allocate space for the excitation energy calculation
C
      KFRSAV = KFREE
      LFRSAV = LFREE
      CALL MEMOPT('REAL',X1,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',X2,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',Y1,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',Y2,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',DG ,NDIMX*RCW,CC,KFREE,LFREE,ALLOC)
      MAXDIM = MAX0(6,2*MXDIMRP+2)
      CALL MEMOPT('REAL',FREQR,MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FREQI,MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FREQD,MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',CCC,MAXDIM*MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB1,MAXDIM*MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB2,MAXDIM*MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB3,MAXDIM*MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB4,MAXDIM*MAXDIM,CC,KFREE,LFREE,ALLOC)
      NBUF1 = MAX0(JVVOO(NREP+1),JVOVO(NREP+1))
      CALL MEMOPT('REAL',BUF1,NBUF1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BUF2,NBUF1*RCW,CC,KFREE,LFREE,ALLOC)
      MXCORR = KFREE
C
      IF (ICALC.LE.1) THEN
         if (myproc.eq.master) 
     &      WRITE (IW,1001) "excitation energies",KFREE
         KFREE = KFRSAV
         LFREE = LFRSAV
         RETURN
      ENDIF
C
C  Solve relativistic Random Phase Approximation equations
C
      if (myproc.eq.master) 
     &    WRITE (IW,1009) MXITRP,MXDIMRP,10.0D0**(-NTOLRP)
      MAXIT  = MXITRP
      TOL = 10.0D0**(-NTOLRP)
C
      DO IREP = 1, NREP
        IF (NEXC(IREP).NE.0) THEN
          if (myproc.eq.master)
     &       WRITE (IW,1011) NEXC(IREP),REPNA(IREP+NREP)
          CALL RPAB
     &        (EPS,CC(X1),CC(X2),CC(Y1),CC(Y2),CC(DG),CC(BUF1),
     &        CC(BUF2),CC(CCC),CC(BB1),CC(BB2),CC(BB3),CC(BB4),
     &        CC(FREQR),CC(FREQI),CC(FREQD),
     &        NEXC(IREP),IREP,TOL,IPRNT,DEBUG,TIMING)
          CALL FLSHFO(IW)
        ENDIF
      ENDDO
C
      RETURN
1001  FORMAT (" Core used for ",A," :",T50,I10," 8-byte words")
1009  FORMAT (//" Excitation energy module (RPA)"
     &        /" Maximum number of iterations :",T40,I5
     &        /" Maximum size of reduced space :",T40,I5
     &        /" Convergence criterium :",T38,E7.1)
1011  FORMAT (//" Random Phase Approximation : ",
     &        /" Calculate",I3," excitation energies for irrep ",A4)
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCFSPC (ICALC,CC,KFREE,LFREE,MXCORR,EPS1,EPS,
     &                  NSP,IREPSP,IREPSPI,MREMAIN)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Driver for Fock space coupled cluster calculations
C
C     Menu driven routine. Depending on value of ICALC
C
C       1) Calculate memory requirements for the different modules
C       2) Calculate Fock space coupled cluster energies at the
C          - CCSD level
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
      REAL*8 CC(*)
      REAL*8 EPS1(*),EPS(*)
      DIMENSION IREPSP(*),IREPSPI(*)
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "iobuf.inc"
      INCLUDE "diis.inc"
      INCLUDE "eqns.inc"
      INCLUDE "results.inc"
      INCLUDE "inpt.inc"
      INCLUDE "symm.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
C
C---------------Local variables--------------------------------------
C
      LOGICAL ALLOC,FOCKSP,REPORT
      INTEGER IFSS(6)
      REAL*8 TOL
C
C---------------Executable code--------------------------------------
C
      ALLOC = ICALC.GE.2
      IF (ICALC.LE.0) RETURN
      EQNS = 'FOCKSP'
      FOCKSP = .TRUE.
      REPORT = ICALC.GT.1
      IF (REPORT.and.(myproc.eq.master)) WRITE (IW,1007)
C
C Allocate space for the Fock space CCSD energy calculation
C
      KFRSAV = KFREE
      LFRSAV = LFREE
      MXCORR = 0
C
C  Set up symmetry tables and parallel distribution list
C  for use in Fock space calculations
C
      CALL SYMTAB (NELEC,NFROZ,NINACT,NACT,NSP,EPS1,EPS,IREPSP,IREPSPI,
     &             FOCKSP,REPORT)
C
C     Ask for the memory requirements of the modules
C
      MXCORR1 = 0
      CALL CCSETI (ICALC,CC,KFREE,LFREE,MXCORR1,MREMAIN,EPS,
     &             NSP,IREPSP,IREPSPI)
      MXCORR = MAX0(MXCORR,MXCORR1)
C
C     Set restart on sorted integrals to false
C
      IMSTAT(1) = 0
      IMSTAT(2) = 0
      IMSTAT(3) = 0
C
C Allocate space for the calculation of the amplitudes
C
      CALL MEMOPT('REAL',FVO,NFVO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',FVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',T1,NDIMT1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',T2,NDIMT2*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',S1,NDIMT1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',S2,NDIMT2*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',AZ,NV1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',H ,NV4*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',HO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',HV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',HOV,NFVO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',GOO,NFOO*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',GVV,NFVV*RCW,CC,KFREE,LFREE,ALLOC)
      MAXDIM = MXDIMCC
      CALL MEMOPT('REAL',CCC,MAXDIM,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB1,(MAXDIM+1)*(MAXDIM+2),CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BB2,(MAXDIM+1)*(MAXDIM+2),CC,KFREE,LFREE,ALLOC)
      NBUF1 = MAX0(JOOOO(NREP+1),JVOOO(NREP+1),
     &             JVVOO(NREP+1),JVOVO(NREP+1))
      NBUF2 = NBUF1
      CALL MEMOPT('REAL',BUF1,NBUF1*RCW,CC,KFREE,LFREE,ALLOC)
      CALL MEMOPT('REAL',BUF2,NBUF2*RCW,CC,KFREE,LFREE,ALLOC)
C
C     Calculate size of the 3rd work array
C     The last array is used to buffer in the <VV||VV> and <VO||VV>
C     integrals, start by making it as large as possible.
C
      NBUF3 = (LFREE - 4) / RCW
C
C     Calculate maximum size necessary for the VOVV and VVVV buffers
C
      NV5IRP = 1
      NV6IRP = 1
      DO IRP = 1, NREP
         NV5IRP = MAX0(NV5IRP,NVO (IRP)*NVVT(IRP))
         NV6IRP = MAX0(NV6IRP,NVVT(IRP)*NVVT(IRP))
      ENDDO
C
      NVIRP = MAX0(NV5IRP,NV6IRP)
      NBUF3 = MIN0(NVIRP,NBUF3)
C
C     Check the minimum size for the general use of this array
C
      NBUF3 = MAX0(NBUF1,NBUF3)
C
C     Allocate the work array
C
      CALL MEMOPT('REAL',BUF3,NBUF3*RCW,CC,KFREE,LFREE,ALLOC)
C
      MXCORR = MAX0(MXCORR,KFREE)
C
      IF (ICALC.LE.1) THEN
         if (myproc.eq.master)
     &   WRITE (IW,1001) "Fock space CCSD energies",MXCORR
         KFREE = KFRSAV
         LFREE = LFRSAV
C
C        Reset symmetry tables to normal (single reference CC use)
C
         EQNS = '      '
         FOCKSP = .FALSE.
         CALL SYMTAB (NELEC,NFROZ,NINACT,NACT,NSP,EPS1,EPS,
     &                IREPSP,IREPSPI,FOCKSP,REPORT)
         RETURN
      ENDIF
C
C     Read the Fock matrix from file
C
      CALL FMTOFILE (.FALSE.,CC(FVO),CC(FOO),CC(FVV))
C
C     Solve relativistic Fock space CCSD equations
C
      if (myproc.eq.master)
     &   WRITE (IW,1008) MXITFS,MXDIMFS,10.0D0**(-NTOLFS)
      MAXDIM = MXDIMFS
      MAXIT  = MXITFS
      TOL = 10.0D0**(-NTOLFS)
C
C     Initialize T1 and T2 amplitudes
C
      CALL XCOPY (NDIMT1,CC(FVO),1,CC(T1),1)
      CALL GETVVOO (CC(T2))
      CALL DENOMF(EPS,CC(T1),CC(T2),CC(T1),CC(T2),1)
C
      IFSS(1) = 00
      IFSS(2) = 01
      IFSS(3) = 10
      IFSS(4) = 11
      IFSS(5) = 02
      IFSS(6) = 20
C
C     Solve Fock space equation sector by sector
C
      DO ISECT = 1, 3
C     Only sectors (0,1) and (1,0) work....
      IF (FSSECT(ISECT).NE.0) THEN
      ICURFSS = IFSS(ISECT)
      if (myproc.eq.master) WRITE (IW,1009) ICURFSS
      CALL CCEQN(EPS,CC(FOO),CC(FVO),CC(FVV),CC(T1),CC(S1),
     &           CC(T2),CC(S2),CC(AZ),DUM,CC(H),CC(HO),CC(HV),CC(HOV),
     &           CC(GOO),CC(GVV),CC(BUF1),CC(BUF2),CC(BUF3),
     &           CC(CCC),CC(BB1),CC(BB2),
     &           TOL,NBUF2,NBUF3)
      ENDIF
      ENDDO
C
      CALL MEMREL('CCENER',CC,1,KFRSAV,KFREE,LFREE)
C
      RETURN
1001  FORMAT (" Core used for ",A," :",T50,I10," 8-byte words")
1007  FORMAT (//" Fock space CCSD Energy calculations",
     &        /" Module written by Ephraim Eliav & Luuk Visscher, ",
     &         "July 1999")
1008  FORMAT (//" Fock space CCSD options :"
     &        /" Maximum number of iterations :",T40,I5
     &        /" Maximum size of DIIS space :",T40,I5
     &        /" Convergence criterium :",T38,E7.1)
1009  FORMAT (//" Solving equations for sector ",I2/)
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCDINI
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Initialize the dump file and status information.
C
C     Now extended in case of a shared file system: the individual
C     MCCRES files need unique names ! => node number appended to
C     file name. ==> inclusion of ccpar.inc which contains the
C     current MPI data for this specific invocation. We allow for
C     a node number range of 0..999 (three digit node number) which
C     corresponds to a maximum of 1000 nodes.
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "results.inc"
      INCLUDE "inpt.inc"
      INCLUDE "symm.inc"
      INCLUDE "param.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
C
C---------------Local variables--------------------------------------
C
      REAL*8 BUFF(RSRCLEN)
      LOGICAL TOBE
C
C---------------Executable code--------------------------------------
C
C     If MPI is active generate the node-unique file name
C     otherwise use file name without further extension.
C     the global quit routine can be found in gp/gptrygve.F
C
C     set generic RESTART file name
C  
      RSBASF='MCCRES'
C
#if defined (VAR_MPI)
      IF (MYPROC .LT. 10) THEN    !  MPI ID has one digit
         WRITE (RSFILN,'(A6,A1,I1)') RSBASF,'.',MYPROC
         LRSFIL=8
      ELSEIF (MYPROC .LT. 100) THEN  ! MPI ID has two digits
         WRITE (RSFILN,'(A6,A1,I2)') RSBASF,'.',MYPROC
         LRSFIL=9
      ELSEIF (MYPROC .LT. 1000) THEN  ! MPI ID has three digits
         WRITE (RSFILN,'(A6,A1,I3)') RSBASF,'.',MYPROC
         LRSFIL=10
      ELSE
         CALL QUIT("NMPROC.GT.1000! EXTEND CCDINI.F RESTART MODULE")
      ENDIF
#else
      RSFILN=RSBASF
      LRSFIL=6
#endif
C
C     Check the status of the individual restart file
C
      IRECL = IRECLEN (RSRCLEN,0,0)
      INQUIRE (FILE=RSFILN(1:LRSFIL),EXIST=TOBE)
c
c     Restart is not fool-proof yet : disabled
c
C here: if a MCCRES.XXX file exists at the beginning of the
C ccsd(t) run it will be deleted in any case.... this goes out later on....

      if (tobe) then
         OPEN (MCCRES,FILE=RSFILN(1:LRSFIL),ACCESS='DIRECT',
     &         STATUS='OLD',RECL=IRECL)
         close (MCCRES,STATUS='DELETE')
         tobe = .false.
      endif

C here: if  the restart file exists we restart...

      IF (TOBE) THEN
         OPEN (MCCRES,FILE=RSFILN(1:LRSFIL),ACCESS='DIRECT',
     &         STATUS='OLD',RECL=IRECL)
C
C         Read the input information from the previous run
C
C         Not implemented yet
C
C         Read the status information
C
          READ (MCCRES,REC=2) IMSTAT
C
C         Read the energies (read the whole common block)
C
          READ (MCCRES,REC=3) BUFF
          CALL DCOPY(7,BUFF,1,ETOT,1)

C ... if it doesn't exist we create it and write amplitudes out there...

      ELSE

         OPEN (MCCRES,FILE=RSFILN(1:LRSFIL),ACCESS='DIRECT',
     &         STATUS='NEW',RECL=IRECL)
         CALL DCOPY(7,A0,0,ETOT,1)
         DO I = 1, NSTATS
            IMSTAT(I) = 0
         ENDDO
      ENDIF
C
C     Initialize the status information
C     When restarting the previous status is retained if the module
C     was on the menu.
C
      IF (DOSORT.AND.IMSTAT(1).EQ.0)             IMSTAT(1) = 1
      IF (DOSORT.AND.IMSTAT(2).EQ.0)             IMSTAT(2) = 1
      IF (DOSORT.AND.IMSTAT(3).EQ.0)             IMSTAT(3) = 1
      IF (DOENER.AND.DOMP2.AND.IMSTAT(1).EQ.0)   IMSTAT(4) = 1
      IF (DOENER.AND.DOCCSD.AND.IMSTAT(1).EQ.0)  IMSTAT(5) = 1
      IF (DOENER.AND.DOCCSDT.AND.IMSTAT(1).EQ.0) IMSTAT(6) = 1
C
C     Initialize the record information
C
      IRECIN = 1 ! Input for the current run
      IRECST = 2 ! Status of the current run
      IRECEN = 3 ! Energies and other results
      IRECT1 = 4 ! T1 amplitudes
C
C     The starting record of the T2 amplitudes is set when the
C     length of the amplitude vectors is known.
C
      CLOSE (MCCRES,STATUS='KEEP')
C
C since a unique restart file name was created in CCDINI we do not
C want to regenerate it in CCDUMP ==> we keep this file name in the
C COMMON BLOCK 
C
      CALL CCDUMP
C
      RETURN
 1000 FORMAT (3X,'Step : ',A,' done in previous run; will be skipped')
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCDUMP
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Dump all the information in the input and restart block
C     to the begin of the restart file
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "results.inc"
      INCLUDE "inpt.inc"
C
C---------------Local variables--------------------------------------
C
      REAL*8 BUFF(RSRCLEN)
C
C---------------Executable code--------------------------------------
C
      IRECL = IRECLEN (RSRCLEN,0,0)
      OPEN (MCCRES,FILE=RSFILN(1:LRSFIL),ACCESS='DIRECT',
     &      STATUS='OLD',RECL=IRECL)
C
C     Dump the input information
C
C     Not implemented yet
C
C     Dump the status information
C
      WRITE (MCCRES,REC=2) IMSTAT
C
C     Dump the energies (write the whole common block)
C
      CALL DCOPY(7,ETOT,1,BUFF,1)
      WRITE (MCCRES,REC=3) BUFF
C
      CLOSE (MCCRES,STATUS='KEEP')
C
      RETURN
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE CCSUMM
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Write summary of the results, based on the restart file
C
C---------------Routines called----------------------------------------
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "files.inc"
      INCLUDE "results.inc"
      INCLUDE "inpt.inc"
      INCLUDE "ccpar.inc"
C
C---------------Local variables--------------------------------------
C
      REAL*8 BUFF(RSRCLEN)
      CHARACTER DATEX*10,TIMEX*8
      CHARACTER*30 STATCH(0:4)
      DATA STATCH/'Never asked for              ',
     &            'On menu but not yet called   ',
     &            'Started, restartable         ',
     &            'Completed, restartable       ',
     &            'Completed, not restartable   '/
C
C---------------Executable code--------------------------------------
C
      IRECL = IRECLEN (RSRCLEN,0,0)
      OPEN (MCCRES,FILE=RSFILN(1:LRSFIL),ACCESS='DIRECT',STATUS='OLD',
     &      RECL=IRECL)
C
C     Read the status information
C
      READ (MCCRES,REC=2) IMSTAT
C
C     Read the energies (read the whole common block)
C
      READ (MCCRES,REC=3) BUFF
      CALL DCOPY(7,BUFF,1,ETOT,1)
C
      CLOSE (MCCRES,STATUS='KEEP')
C
      CALL DAYTIME (DATEX,TIMEX)
C
      if (myproc.eq.master) WRITE (IW,1000) ('-',I=1,80)
C
C     Write date & time
C
      if (myproc.eq.master) WRITE (IW,1001) DATEX,TIMEX
C
C     Write status information
C
      if (myproc.eq.master) then
C
      WRITE (IW,1002)
C
      WRITE (IW,1021) STATCH(IMSTAT(1))
      WRITE (IW,1022) STATCH(IMSTAT(2))
      WRITE (IW,1023) STATCH(IMSTAT(3))
      WRITE (IW,1024) STATCH(IMSTAT(4))
      WRITE (IW,1025) STATCH(IMSTAT(5))
      WRITE (IW,1026) STATCH(IMSTAT(6))
C
C     Write energies
C
      WRITE (IW,1003) 
      WRITE (IW,1070) ESCF
      WRITE (IW,1072) EMP2
      WRITE (IW,1073) ECCSD
      WRITE (IW,1074) ET1
      WRITE (IW,1075) ET2
      WRITE (IW,1076) ET3
      WRITE (IW,1080) ESCF+EMP2
      WRITE (IW,1081) ESCF+ECCSD
      WRITE (IW,1082) ESCF+ECCSD+ET1
      WRITE (IW,1083) ESCF+ECCSD+ET1+ET2
      WRITE (IW,1084) ESCF+ECCSD+ET1+ET3
C
      WRITE (IW,1000) ('-',I=1,80)
C
      endif
C
 1000 FORMAT (//80A)
 1001 FORMAT (//" Today is :",T15,A10/" The time is :",T17,A8)
 1002 FORMAT (/' Status of the calculations')
 1003 FORMAT (/' Overview of calculated energies')
 1021 FORMAT (' Integral sort # 1 :',T40,A30)
 1022 FORMAT (' Integral sort # 2 :',T40,A30)
 1023 FORMAT (' Fock matrix build :',T40,A30)
 1024 FORMAT (' MP2 energy calculation :',T40,A30)
 1025 FORMAT (' CCSD energy calculation :',T40,A30)
 1026 FORMAT (' CCSD(T) energy calculation :',T40,A30)
 1070 FORMAT('@ SCF energy :',T40,F25.15)
 1072 FORMAT('@ MP2 correlation energy :',T40,F25.15)
 1073 FORMAT('@ CCSD correlation energy :',T40,F25.15)
 1074 FORMAT('@ 4th order triples correction :',T40,F25.15)
 1075 FORMAT('@ 5th order triples (T) correction :',T40,F25.15)
 1076 FORMAT('@ 5th order triples -T  correction :',T40,F25.15)
 1080 FORMAT('@ Total MP2 energy :',T40,F25.15)
 1081 FORMAT('@ Total CCSD energy :',T40,F25.15)
 1082 FORMAT('@ Total CCSD+T  energy :',T40,F25.15)
 1083 FORMAT('@ Total CCSD(T) energy :',T40,F25.15)
 1084 FORMAT('@ Total CCSD-T  energy :',T40,F25.15)
C
      RETURN
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE RDSYMI (NSP,EPS1,IREPSP)
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Read symmetry information from MOLFDIR
C
C---------------Routines called----------------------------------------
C
C
C---------------Last modified------------------------------------------
C
C     Author : Luuk Visscher
C
C---------------Calling variables--------------------------------------
C
      INTEGER IREPSP(*)
      REAL*8 EPS1(*)
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "param.inc"
      INCLUDE "files.inc"
      INCLUDE "results.inc"
      INCLUDE "symm.inc"
      INCLUDE "inpt.inc"
      INCLUDE "complex.inc"
      INCLUDE "ccpar.inc"
#if defined (VAR_MPI)
      INCLUDE 'mpif.h'
      DIMENSION ISTAT(MPI_STATUS_SIZE)
#endif
C
C---------------Local variables--------------------------------------
C
      CHARACTER*14 REPNT(16)
C
C---------------Executable code--------------------------------------
C
C     Read symmetry information (master node only)
C
      IF (MYPROC.EQ.MASTER) THEN
       OPEN (MRCONEE,FILE='MRCONEE',FORM='UNFORMATTED')
       READ (MRCONEE) NSP,BREIT,ECORE
       READ (MRCONEE) NSYMRP,(REPNT(IRP),IRP=1,NSYMRP) 
     &               ,(NELEC(IRP),IRP=1,NSYMRP)
       DO IRP = 1, NSYMRP
          NELEC(IRP) = 0
       ENDDO
       READ (MRCONEE) NREP,(REPNA(IRP),IRP=1,2*NREP)
       READ (MRCONEE) ((MULTB(I,J,1),I=1,2*NREP),J=1,2*NREP)
C      IREPSP is to be used as 2-dimensional array, read it like that
       READ (MRCONEE) (IREPSP(ISP),IREPSP(NSP+ISP),
     &                 EPS1(ISP),ISP=1,NSP)
       CLOSE (MRCONEE,STATUS='KEEP')
C
C      Right adjust representation names
C
       DO IRP = 1, NSYMRP
          REPN(IRP) = REPNT(IRP)(1:4)
          CALL BLANKR (4,REPN(IRP))
       ENDDO
       DO IRP = 1, NREP
          CALL BLANKR (4,REPNA(IRP))
       ENDDO
      ENDIF
C
C     Make inverse of multiplication table
C
      DO JREP = 1, 2*NREP
         DO IREP = 1, 2*NREP
            KREP = MULTB(IREP,JREP,1)
            MULTB(IREP,KREP,2) = JREP
         ENDDO
      ENDDO
C
C     Get rid of offset for boson reps
C
      DO JREP = 1, NREP
         DO IREP = 1, NREP
            MULTB(IREP,JREP,1) = MULTB(IREP,JREP,1) - NREP
            MULTB(IREP,JREP,2) = MULTB(IREP,JREP,2) - NREP
         ENDDO
      ENDDO
      DO JREP = NREP + 1, 2*NREP
         DO IREP = NREP + 1, 2*NREP
            MULTB(IREP,JREP,1) = MULTB(IREP,JREP,1) - NREP
            MULTB(IREP,JREP,2) = MULTB(IREP,JREP,2) - NREP
         ENDDO
      ENDDO
C
C     Distribute the information read from MRCONEE
C
#if defined (VAR_MPI)
      IF (NMPROC.GT.1) THEN
         CALL MPI_BCAST(NSP,1,MPI_INTEGER,MASTER,MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(BREIT,1,MPI_LOGICAL,MASTER,MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(ECORE,1,MPI_DOUBLE_PRECISION,MASTER,
     &                  MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(NSYMRP,1,MPI_INTEGER,MASTER,MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(REPN,NSYMRP*4,MPI_CHARACTER,MASTER,
     &                  MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(NELEC,NSYMRP,MPI_INTEGER,MASTER,
     &                  MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(NREP,1,MPI_INTEGER,MASTER,MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(REPNA,2*NREP*4,MPI_CHARACTER,MASTER,
     &                  MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(MULTB,MXREP*MXREP*8,MPI_INTEGER,MASTER,
     &                  MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(IREPSP,2*NSP,MPI_INTEGER,MASTER,
     &                  MPI_COMM_WORLD,IERR)
         CALL MPI_BCAST(EPS1,NSP,MPI_DOUBLE_PRECISION,MASTER,
     &                  MPI_COMM_WORLD,IERR)
      END IF
#endif
      RETURN
      END
C&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
      SUBROUTINE DISLIST
C
      IMPLICIT INTEGER (A-Z)
C
C---------------Description--------------------------------------------
C
C     Set up parallel distribution lists for the integral classes VVVV,
C     VOVV and VVOO stored in IDIST(6,6,8) common: ccpar.inc
C     the distribution is performed wrt the second batch
C
C     IOFF counts number of NVVT-sized batches on this node and irrep
C     JOFF points to the starting address in the full integral list
C     KOFF points to the relative starting address in the node integral list
C
C     JOFF and KOFF can be used to go from the absolute indexing to
C     the relative indexing. In both cases the begin is set at zero (last
C     integral of the previous block) and the end to the last integral in
C     the block
C
C---------------Common Blocks--------------------------------------
C
      INCLUDE "symm.inc"
      INCLUDE "complex.inc"
      INCLUDE "files.inc"
      INCLUDE "ccpar.inc"
C
C---------------Executable code--------------------------------------
C
C ********
C *** VVVV
C ********
C
      KOFF = 0
      DO IREP = 1, NREP
         MTOT = NVVT(IREP)
         NTOT = NVVT(IREP)
         NBTCH = NTOT / NMPROC
         NREST = MOD(NTOT,NMPROC)
         IOFF = 0
C        write(IW,*) 'splitting for IREP:',IREP
C        write(IW,*) 'NVVT(IREP),NBTCH,NREST: ',NVVT(IREP),
C    &                NBTCH,NREST
C        write(IW,*) ' '
         DO I = 1, NMPROC
C
C           Calculate absolute start address of this batch
C
            JOFF = IVVVVTT(IREP) + IOFF * MTOT
C
C           Create even distribution, the higher nodes get the remains
C
            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1
C
C           We need this information for our own process
C
            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,1,IREP) = IOFF
               IDIST(2,1,IREP) = IOFF + NBTCH
               IDIST(3,1,IREP) = JOFF
               IDIST(4,1,IREP) = JOFF + NBTCH * MTOT
               IDIST(5,1,IREP) = KOFF
               IDIST(6,1,IREP) = KOFF + NBTCH * MTOT
               KOFF = KOFF + NBTCH * MTOT
            ENDIF
            IOFF = IOFF + NBTCH
         ENDDO
      ENDDO
C
C     NV6PAR is the number of VVVV integrals which is to handle
C     on THIS node. Can still be too large to be sorted in ONE pass.
C     ==> instead of NV6 the number of passes is calculated from NV6PAR !
C     ==> hierarchy is first determination of individual numbers
C                      second local sorting of VOVV and VVVV classes.
C
      NV6PAR =  KOFF
C
C ********
C *** VOVV
C ********
C
      KOFF = 0
      DO IREP = 1, NREP
         NVOTOT = NVO (IREP)
         NVVTOT = NVVT(IREP)
         NBTCH = NVVTOT / NMPROC
         NREST = MOD(NVVTOT,NMPROC)
         IOFF = 0
         DO I = 1, NMPROC
C
C           Calculate absolute start address of this batch
C
            JOFF = IVOVVT(IREP) + IOFF * NVOTOT
C
C           Create even distribution, the higher nodes get the remains
C
            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1
C
C           We need this information for our own process
C
            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,2,IREP) = IOFF
               IDIST(2,2,IREP) = IOFF + NBTCH
               IDIST(3,2,IREP) = JOFF
               IDIST(4,2,IREP) = JOFF + NBTCH * NVOTOT
               IDIST(5,2,IREP) = KOFF
               IDIST(6,2,IREP) = KOFF + NBTCH * NVOTOT
               KOFF = KOFF + NBTCH * NVOTOT
            ENDIF
            IOFF = IOFF + NBTCH
         ENDDO
      ENDDO
C
C     NV5PAR is the number of VOVV integrals which is to handle
C     on THIS node. Can still be too large to be sorted in ONE pass.
C     ==> instead of NV5 the number of passes is calculated from NV5PAR !
C     ==> hierarchy is first determination of individual numbers
C                      second local sorting of VOVV and VVVV classes.
C
      NV5PAR =  KOFF
C
C
C ****************************************************************
C *** HINTM VVOO contraction, column number in corresponding IRREP
C ****************************************************************
C
      DO IREP = 1, NREP
         JREP=MULTB(IREP+NREP,1+NREP,2)
         MI=MVO(IREP)
         MVOTOT=MVO(JREP)
         NBTCH = MVOTOT / NMPROC
         NREST = MOD(MVOTOT,NMPROC)
         IOFF = J2VOVO(IREP)*RCW + 1
         JOFF = J2VOVO(JREP)*RCW + 1
         DO I = 1, NMPROC
 
C           Create even distribution, the higher nodes get the remains
 
            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1
 
C           Process-local information
 
            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,4,JREP) = NBTCH
               IDIST(2,4,JREP) = IOFF
               IDIST(3,4,JREP) = JOFF
            ENDIF
            IOFF = IOFF + MI*NBTCH*RCW
            JOFF = JOFF + NBTCH*RCW
         ENDDO
      ENDDO

C
C ****************************************************************
C *** index range distribution for W(A,K,C,I)*T(C,K)
C *** only irrep 1 (totally symmetric ) is needed in the ket space =>
C *** the bosonic bra irrep also has to be 1 and we do not need two
C *** different arrays.
C ****************************************************************
C
      MVOTOT=MVO(1)
      NBTCH = MVOTOT / NMPROC
      NREST = MOD(MVOTOT,NMPROC)
      IOFF = 1
      JOFF = 1
      DO I = 1, NMPROC

C        Create even distribution, the higher nodes get the remains

         IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1

C        Process-local information

         IF (I.EQ.MYPROC+1) THEN
            IDIST(1,3,1) = NBTCH
            IDIST(2,3,1) = IOFF
            IDIST(3,3,1) = JOFF
         ENDIF
         IOFF = IOFF + MVOTOT*NBTCH*RCW
         JOFF = JOFF + NBTCH*RCW
      ENDDO

C
C ****************************************************************
C ***  VVOO distr. for AINTM * TAU contraction
C ***  Both arrays have an equal symmetry structure G(i) = G(j)
C ***  suitable for the usage of the CNTRCT call.===> we use this here.
C ***  batches are created according to the individual irreps
C ***  IOFF: source offset    JOFF: start offset of second matrix
C ****************************************************************
C
      DO IREP = 1, NREP
         NOOTOT=NOOT(IREP)
         NVVTOT=NVVT(IREP)
         NBTCH = NOOTOT / NMPROC
         NREST = MOD(NOOTOT,NMPROC)
         IOFF = IVVOOTT(IREP)*RCW + 1
         JOFF = IOOOOTT(IREP)*RCW + 1
         DO I = 1, NMPROC

C           Create even distribution, the higher nodes get the remains

            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1

C           Process-local information

            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,5,IREP) = NBTCH
               IDIST(2,5,IREP) = IOFF
               IDIST(3,5,IREP) = JOFF
            ENDIF
            IOFF = IOFF + NVVTOT*NBTCH*RCW
            JOFF = JOFF + NBTCH*RCW
         ENDDO
      ENDDO

C
C ****************************************************************
C ***  distr. for the contraction TAU * VOOO in T1EQN1.
C ***  the arrays are organised according to 
C ***  NV(IREP),NVOOT(IREP) * NVOOT(IREP),NO(IREP)
C ***  Both arrays have an equal symmetry structure G(i) = G(j)
C ***  suitable for the usage of the CNTRCT call.===> we use this here.
C ***  IOFF: source offset for first matrix
C ***  JOFF: entry point for second matrix
C ****************************************************************
C
      DO IREP = 1, NREP
         NV33   = NV(IREP)
         NVOO33 = NVOOT(IREP)
         NBTCH = NVOO33 / NMPROC
         NREST = MOD(NVOO33,NMPROC)
         IOFF = LVVOOT (IREP)*RCW + 1
         JOFF = LOVOOT (IREP)*RCW + 1
         DO I = 1, NMPROC

C           Create even distribution, the higher nodes get the remains

            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1

C           Process-local information

            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,6,IREP) = NBTCH
               IDIST(2,6,IREP) = IOFF
               IDIST(3,6,IREP) = JOFF
            ENDIF
            IOFF = IOFF + NV33*NBTCH*RCW
            JOFF = JOFF + NBTCH*RCW
         ENDDO
      ENDDO

C
C ****************************************************************
C ***  distr. for the contraction T2 * GOINTM in T2EQNS
C ***  the arrays are organised according to 
C ***  NVVOT(IREP),NO(IREP) * NO(IREP),NO(IREP)
C ***  Both arrays have an equal symmetry structure G(i) = G(j)
C ***  suitable for the usage of the CNTRCT call.===> we use this here.
C ***  IOFF: source offset for first matrix
C ***  JOFF: entry point for second matrix
C ****************************************************************
C
      DO IREP = 1, NREP
         NVVO33 = NVVOT(IREP)
         NO33   = NO(IREP)
         NBTCH = NO33 / NMPROC
         NREST = MOD(NO33,NMPROC)
         IOFF = KVVOOT(IREP)*RCW + 1
         JOFF = IOO(IREP)*RCW + 1
         DO I = 1, NMPROC

C           Create even distribution, the higher nodes get the remains

            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1

C           Process-local information

            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,7,IREP) = NBTCH
               IDIST(2,7,IREP) = IOFF
               IDIST(3,7,IREP) = JOFF
            ENDIF
            IOFF = IOFF + NVVO33*NBTCH*RCW
            JOFF = JOFF + NBTCH*RCW
         ENDDO
      ENDDO

C ****************************************************************
C ***  distr. for the contraction T1(A,K) * W(KB,IJ)
C ***  the arrays are organised according to 
C ***  NV(IREP),NO(IREP) * NO(IREP)*NVOOT(IREP)
C ***  Both arrays have an equal symmetry structure G(i) = G(j)
C ***  suitable for the usage of the CNTRCT call.===> we use this here.
C ***  IOFF: source offset for first matrix
C ***  JOFF: entry point for second matrix
C ****************************************************************
C
      DO IREP = 1, NREP
         NV33 = NV(IREP)
         NO33 = NO(IREP)
         NBTCH = NO33 / NMPROC
         NREST = MOD(NO33,NMPROC)
         IOFF = IVO(IREP)*RCW + 1
         JOFF = LOVOOT(IREP)*RCW + 1
         DO I = 1, NMPROC

C           Create even distribution, the higher nodes get the remains

            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1

C           Process-local information

            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,8,IREP) = NBTCH
               IDIST(2,8,IREP) = IOFF
               IDIST(3,8,IREP) = JOFF
            ENDIF
            IOFF = IOFF + NV33*NBTCH*RCW
            JOFF = JOFF + NBTCH*RCW
         ENDDO
      ENDDO

C ****************************************************************
C ***  distr. for the contraction T1(A,K) * W(BK,IC) * T1(C,J)
C ***  the permutation operators are taken into account by the sorters
C ***  CNTRCT organization: NVOO(IRP),NV(IRP) * NV(IRP),NO(IRP)
C ***  Both arrays have an equal symmetry structure G(i) = G(j)
C ***  suitable for the usage of the CNTRCT call.===> we use this here.
C ***  IOFF: source offset for first matrix
C ***  JOFF: entry point for second matrix
C ****************************************************************
C
      DO IREP = 1, NREP
         NVOO33 = NVOO(IREP)
         NV33   = NV(IREP)
         NBTCH = NV33 / NMPROC
         NREST = MOD(NV33,NMPROC)
         IOFF  = KVOOV(IREP)*RCW + 1
         JOFF  = IVO(IREP)*RCW + 1
         DO I = 1, NMPROC

C           Create even distribution, the higher nodes get the remains

            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1

C           Process-local information

            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,9,IREP) = NBTCH
               IDIST(2,9,IREP) = IOFF
               IDIST(3,9,IREP) = JOFF
            ENDIF
            IOFF = IOFF + NVOO33*NBTCH*RCW
            JOFF = JOFF + NBTCH*RCW
         ENDDO
      ENDDO

C
C
C *******************************
C *** HINTM  contraction in T2EQN
C *******************************
C
      OFF1 = 1
      OFF2 = 1
      OFF3 = 1
      DO IREP = 1, NREP
         JREP=MULTB(IREP+NREP,1+NREP,2)
         M=MVO(IREP)
         N=MVO(JREP)
         K=MVO(IREP)
         MVOTOT=MVO(IREP)
         NBTCH = MVOTOT / NMPROC
         NREST = MOD(MVOTOT,NMPROC)
         IOFF = OFF1
         JOFF = OFF2
         DO I = 1, NMPROC
 
C           Create even distribution, the higher nodes get the remains
 
            IF (NMPROC-NREST+1.EQ.I) NBTCH = NBTCH + 1
 
C           Process-local information
 
            IF (I.EQ.MYPROC+1) THEN
               IDIST(1,10,JREP) = NBTCH
               IDIST(2,10,JREP) = IOFF
               IDIST(3,10,JREP) = JOFF
            ENDIF
            IOFF = IOFF + M*NBTCH*RCW
            JOFF = JOFF + NBTCH*RCW
         ENDDO
C
         OFF1 = OFF1 + M * K * RCW
         OFF2 = OFF2 + K * N * RCW
         OFF3 = OFF3 + M * N * RCW
      ENDDO
C
      RETURN
      END

